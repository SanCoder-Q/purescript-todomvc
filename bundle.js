// Generated by psc version 0.6.2
var PS = PS || {};
PS.Prelude = (function () {
    "use strict";
    var Unit = {
        create: function (value) {
            return value;
        }
    };
    function Semigroupoid($less$less$less) {
        this["<<<"] = $less$less$less;
    };
    function Show(show) {
        this.show = show;
    };
    function Functor($less$dollar$greater) {
        this["<$>"] = $less$dollar$greater;
    };
    function Apply($less$times$greater, __superclass_Prelude$dotFunctor_0) {
        this["<*>"] = $less$times$greater;
        this["__superclass_Prelude.Functor_0"] = __superclass_Prelude$dotFunctor_0;
    };
    function Applicative(__superclass_Prelude$dotApply_0, pure) {
        this["__superclass_Prelude.Apply_0"] = __superclass_Prelude$dotApply_0;
        this.pure = pure;
    };
    function Bind($greater$greater$eq, __superclass_Prelude$dotApply_0) {
        this[">>="] = $greater$greater$eq;
        this["__superclass_Prelude.Apply_0"] = __superclass_Prelude$dotApply_0;
    };
    function Monad(__superclass_Prelude$dotApplicative_0, __superclass_Prelude$dotBind_1) {
        this["__superclass_Prelude.Applicative_0"] = __superclass_Prelude$dotApplicative_0;
        this["__superclass_Prelude.Bind_1"] = __superclass_Prelude$dotBind_1;
    };
    function Num($percent, $times, $plus, $minus, $div, negate) {
        this["%"] = $percent;
        this["*"] = $times;
        this["+"] = $plus;
        this["-"] = $minus;
        this["/"] = $div;
        this.negate = negate;
    };
    function Eq($div$eq, $eq$eq) {
        this["/="] = $div$eq;
        this["=="] = $eq$eq;
    };
    function BoolLike($amp$amp, not, $bar$bar) {
        this["&&"] = $amp$amp;
        this.not = not;
        this["||"] = $bar$bar;
    };
    function Semigroup($less$greater) {
        this["<>"] = $less$greater;
    };
    function showNumberImpl(n) {  return n.toString();};
    function numAdd(n1) {  return function(n2) {    return n1 + n2;  };};
    function numSub(n1) {  return function(n2) {    return n1 - n2;  };};
    function numMul(n1) {  return function(n2) {    return n1 * n2;  };};
    function numDiv(n1) {  return function(n2) {    return n1 / n2;  };};
    function numMod(n1) {  return function(n2) {    return n1 % n2;  };};
    function numNegate(n) {  return -n;};
    function refEq(r1) {  return function(r2) {    return r1 === r2;  };};
    function refIneq(r1) {  return function(r2) {    return r1 !== r2;  };};
    function boolAnd(b1) {  return function(b2) {    return b1 && b2;  };};
    function boolOr(b1) {  return function(b2) {    return b1 || b2;  };};
    function boolNot(b) {  return !b;};
    function concatString(s1) {  return function(s2) {    return s1 + s2;  };};
    var $greater$greater$eq = function (dict) {
        return dict[">>="];
    };
    var $eq$eq = function (dict) {
        return dict["=="];
    };
    var $less$greater = function (dict) {
        return dict["<>"];
    };
    var $less$less$less = function (dict) {
        return dict["<<<"];
    };
    var $less$times$greater = function (dict) {
        return dict["<*>"];
    };
    var $less$dollar$greater = function (dict) {
        return dict["<$>"];
    };
    var $div$eq = function (dict) {
        return dict["/="];
    };
    var $minus = function (dict) {
        return dict["-"];
    };
    var $plus$plus = function (__dict_Semigroup_2) {
        return $less$greater(__dict_Semigroup_2);
    };
    var $plus = function (dict) {
        return dict["+"];
    };
    var $amp$amp = function (dict) {
        return dict["&&"];
    };
    var $dollar = function (f) {
        return function (x) {
            return f(x);
        };
    };
    var unit = {};
    var showNumber = new Show(showNumberImpl);
    var show = function (dict) {
        return dict.show;
    };
    var semigroupoidArr = new Semigroupoid(function (f) {
        return function (g) {
            return function (x) {
                return f(g(x));
            };
        };
    });
    var semigroupString = new Semigroup(concatString);
    var pure = function (dict) {
        return dict.pure;
    };
    var $$return = function (__dict_Monad_5) {
        return pure(__dict_Monad_5["__superclass_Prelude.Applicative_0"]());
    };
    var numNumber = new Num(numMod, numMul, numAdd, numSub, numDiv, numNegate);
    var not = function (dict) {
        return dict.not;
    };
    var liftA1 = function (__dict_Applicative_7) {
        return function (f) {
            return function (a) {
                return $less$times$greater(__dict_Applicative_7["__superclass_Prelude.Apply_0"]())(pure(__dict_Applicative_7)(f))(a);
            };
        };
    };
    var eqNumber = new Eq(refIneq, refEq);
    var boolLikeBoolean = new BoolLike(boolAnd, boolNot, boolOr);
    var ap = function (__dict_Monad_15) {
        return function (f) {
            return function (a) {
                return $greater$greater$eq(__dict_Monad_15["__superclass_Prelude.Bind_1"]())(f)(function (_2) {
                    return $greater$greater$eq(__dict_Monad_15["__superclass_Prelude.Bind_1"]())(a)(function (_1) {
                        return $$return(__dict_Monad_15)(_2(_1));
                    });
                });
            };
        };
    };
    return {
        "$": $dollar, 
        "&&": $amp$amp, 
        "+": $plus, 
        "++": $plus$plus, 
        "-": $minus, 
        "/=": $div$eq, 
        "<$>": $less$dollar$greater, 
        "<*>": $less$times$greater, 
        "<<<": $less$less$less, 
        "<>": $less$greater, 
        "==": $eq$eq, 
        ">>=": $greater$greater$eq, 
        Applicative: Applicative, 
        Apply: Apply, 
        Bind: Bind, 
        BoolLike: BoolLike, 
        Eq: Eq, 
        Functor: Functor, 
        Monad: Monad, 
        Num: Num, 
        Semigroup: Semigroup, 
        Semigroupoid: Semigroupoid, 
        Show: Show, 
        Unit: Unit, 
        ap: ap, 
        boolLikeBoolean: boolLikeBoolean, 
        eqNumber: eqNumber, 
        liftA1: liftA1, 
        not: not, 
        numNumber: numNumber, 
        pure: pure, 
        refEq: refEq, 
        refIneq: refIneq, 
        "return": $$return, 
        semigroupString: semigroupString, 
        semigroupoidArr: semigroupoidArr, 
        show: show, 
        showNumber: showNumber, 
        unit: unit
    };
})();
var PS = PS || {};
PS.FRP_Kefir_Foreign = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    
var kefir =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Kefir.js v0.5.1
	 *  https://github.com/pozadi/kefir
	 */
	;(function(global){
	  "use strict";

	  var Kefir = {};


	function and() {
	  for (var i = 0; i < arguments.length; i++) {
	    if (!arguments[i]) {
	      return arguments[i];
	    }
	  }
	  return arguments[i - 1];
	}

	function or() {
	  for (var i = 0; i < arguments.length; i++) {
	    if (arguments[i]) {
	      return arguments[i];
	    }
	  }
	  return arguments[i - 1];
	}

	function not(x) {
	  return !x;
	}

	function concat(a, b) {
	  var result, length, i, j;
	  if (a.length === 0) {  return b  }
	  if (b.length === 0) {  return a  }
	  j = 0;
	  result = new Array(a.length + b.length);
	  length = a.length;
	  for (i = 0; i < length; i++, j++) {
	    result[j] = a[i];
	  }
	  length = b.length;
	  for (i = 0; i < length; i++, j++) {
	    result[j] = b[i];
	  }
	  return result;
	}

	function find(arr, value) {
	  var length = arr.length
	    , i;
	  for (i = 0; i < length; i++) {
	    if (arr[i] === value) {  return i  }
	  }
	  return -1;
	}

	function findByPred(arr, pred) {
	  var length = arr.length
	    , i;
	  for (i = 0; i < length; i++) {
	    if (pred(arr[i])) {  return i  }
	  }
	  return -1;
	}

	function cloneArray(input) {
	  var length = input.length
	    , result = new Array(length)
	    , i;
	  for (i = 0; i < length; i++) {
	    result[i] = input[i];
	  }
	  return result;
	}

	function remove(input, index) {
	  var length = input.length
	    , result, i, j;
	  if (index >= 0 && index < length) {
	    if (length === 1) {
	      return [];
	    } else {
	      result = new Array(length - 1);
	      for (i = 0, j = 0; i < length; i++) {
	        if (i !== index) {
	          result[j] = input[i];
	          j++;
	        }
	      }
	      return result;
	    }
	  } else {
	    return input;
	  }
	}

	function removeByPred(input, pred) {
	  return remove(input, findByPred(input, pred));
	}

	function map(input, fn) {
	  var length = input.length
	    , result = new Array(length)
	    , i;
	  for (i = 0; i < length; i++) {
	    result[i] = fn(input[i]);
	  }
	  return result;
	}

	function forEach(arr, fn) {
	  var length = arr.length
	    , i;
	  for (i = 0; i < length; i++) {  fn(arr[i])  }
	}

	function fillArray(arr, value) {
	  var length = arr.length
	    , i;
	  for (i = 0; i < length; i++) {
	    arr[i] = value;
	  }
	}

	function contains(arr, value) {
	  return find(arr, value) !== -1;
	}

	function rest(arr, start, onEmpty) {
	  if (arr.length > start) {
	    return Array.prototype.slice.call(arr, start);
	  }
	  return onEmpty;
	}

	function slide(cur, next, max) {
	  var length = Math.min(max, cur.length + 1),
	      offset = cur.length - length + 1,
	      result = new Array(length),
	      i;
	  for (i = offset; i < length; i++) {
	    result[i - offset] = cur[i];
	  }
	  result[length - 1] = next;
	  return result;
	}

	function isEqualArrays(a, b) {
	  var length, i;
	  if (a == null && b == null) {
	    return true;
	  }
	  if (a == null || b == null) {
	    return false;
	  }
	  if (a.length !== b.length) {
	    return false;
	  }
	  for (i = 0, length = a.length; i < length; i++) {
	    if (a[i] !== b[i]) {
	      return false;
	    }
	  }
	  return true;
	}

	function spread(fn, length) {
	  switch(length) {
	    case 0:  return function(a) {  return fn()  };
	    case 1:  return function(a) {  return fn(a[0])  };
	    case 2:  return function(a) {  return fn(a[0], a[1])  };
	    case 3:  return function(a) {  return fn(a[0], a[1], a[2])  };
	    case 4:  return function(a) {  return fn(a[0], a[1], a[2], a[3])  };
	    default: return function(a) {  return fn.apply(null, a)  };
	  }
	}

	function apply(fn, c, a) {
	  var aLength = a ? a.length : 0;
	  if (c == null) {
	    switch (aLength) {
	      case 0:  return fn();
	      case 1:  return fn(a[0]);
	      case 2:  return fn(a[0], a[1]);
	      case 3:  return fn(a[0], a[1], a[2]);
	      case 4:  return fn(a[0], a[1], a[2], a[3]);
	      default: return fn.apply(null, a);
	    }
	  } else {
	    switch (aLength) {
	      case 0:  return fn.call(c);
	      default: return fn.apply(c, a);
	    }
	  }
	}

	function get(map, key, notFound) {
	  if (map && key in map) {
	    return map[key];
	  } else {
	    return notFound;
	  }
	}

	function own(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	function createObj(proto) {
	  var F = function() {};
	  F.prototype = proto;
	  return new F();
	}

	function extend(target /*, mixin1, mixin2...*/) {
	  var length = arguments.length
	    , i, prop;
	  for (i = 1; i < length; i++) {
	    for (prop in arguments[i]) {
	      target[prop] = arguments[i][prop];
	    }
	  }
	  return target;
	}

	function inherit(Child, Parent /*, mixin1, mixin2...*/) {
	  var length = arguments.length
	    , i;
	  Child.prototype = createObj(Parent.prototype);
	  Child.prototype.constructor = Child;
	  for (i = 2; i < length; i++) {
	    extend(Child.prototype, arguments[i]);
	  }
	  return Child;
	}

	var NOTHING = ['<nothing>'];
	var END = 'end';
	var VALUE = 'value';
	var ERROR = 'error';
	var ANY = 'any';

	function noop() {}

	function id(x) {
	  return x;
	}

	function strictEqual(a, b) {
	  return a === b;
	}

	function defaultDiff(a, b) {
	  return [a, b]
	}

	var now = Date.now ?
	  function() { return Date.now() } :
	  function() { return new Date().getTime() };

	function isFn(fn) {
	  return typeof fn === 'function';
	}

	function isUndefined(x) {
	  return typeof x === 'undefined';
	}

	function isArrayLike(xs) {
	  return isArray(xs) || isArguments(xs);
	}

	var isArray = Array.isArray || function(xs) {
	  return Object.prototype.toString.call(xs) === '[object Array]';
	}

	var isArguments = function(xs) {
	  return Object.prototype.toString.call(xs) === '[object Arguments]';
	}

	// For IE
	if (!isArguments(arguments)) {
	  isArguments = function(obj) {
	    return !!(obj && own(obj, 'callee'));
	  }
	}

	function withInterval(name, mixin) {

	  function AnonymousStream(wait, args) {
	    Stream.call(this);
	    this._wait = wait;
	    this._intervalId = null;
	    var $ = this;
	    this._$onTick = function() {  $._onTick()  }
	    this._init(args);
	  }

	  inherit(AnonymousStream, Stream, {

	    _name: name,

	    _init: function(args) {},
	    _free: function() {},

	    _onTick: function() {},

	    _onActivation: function() {
	      this._intervalId = setInterval(this._$onTick, this._wait);
	    },
	    _onDeactivation: function() {
	      if (this._intervalId !== null) {
	        clearInterval(this._intervalId);
	        this._intervalId = null;
	      }
	    },

	    _clear: function() {
	      Stream.prototype._clear.call(this);
	      this._$onTick = null;
	      this._free();
	    }

	  }, mixin);

	  Kefir[name] = function(wait) {
	    return new AnonymousStream(wait, rest(arguments, 1, []));
	  }
	}

	function withOneSource(name, mixin, options) {


	  options = extend({
	    streamMethod: function(StreamClass, PropertyClass) {
	      return function() {  return new StreamClass(this, arguments)  }
	    },
	    propertyMethod: function(StreamClass, PropertyClass) {
	      return function() {  return new PropertyClass(this, arguments)  }
	    }
	  }, options || {});



	  mixin = extend({
	    _init: function(args) {},
	    _free: function() {},

	    _handleValue: function(x, isCurrent) {  this._send(VALUE, x, isCurrent)  },
	    _handleError: function(x, isCurrent) {  this._send(ERROR, x, isCurrent)  },
	    _handleEnd: function(__, isCurrent) {  this._send(END, null, isCurrent)  },

	    _handleAny: function(event) {
	      switch (event.type) {
	        case VALUE: this._handleValue(event.value, event.current); break;
	        case ERROR: this._handleError(event.value, event.current); break;
	        case END: this._handleEnd(event.value, event.current); break;
	      }
	    },

	    _onActivation: function() {
	      this._source.onAny(this._$handleAny);
	    },
	    _onDeactivation: function() {
	      this._source.offAny(this._$handleAny);
	    }
	  }, mixin || {});



	  function buildClass(BaseClass) {
	    function AnonymousObservable(source, args) {
	      BaseClass.call(this);
	      this._source = source;
	      this._name = source._name + '.' + name;
	      this._init(args);
	      var $ = this;
	      this._$handleAny = function(event) {  $._handleAny(event)  }
	    }

	    inherit(AnonymousObservable, BaseClass, {
	      _clear: function() {
	        BaseClass.prototype._clear.call(this);
	        this._source = null;
	        this._$handleAny = null;
	        this._free();
	      }
	    }, mixin);

	    return AnonymousObservable;
	  }


	  var AnonymousStream = buildClass(Stream);
	  var AnonymousProperty = buildClass(Property);

	  if (options.streamMethod) {
	    Stream.prototype[name] = options.streamMethod(AnonymousStream, AnonymousProperty);
	  }

	  if (options.propertyMethod) {
	    Property.prototype[name] = options.propertyMethod(AnonymousStream, AnonymousProperty);
	  }

	}

	function withTwoSources(name, mixin /*, options*/) {

	  mixin = extend({
	    _init: function(args) {},
	    _free: function() {},

	    _handlePrimaryValue: function(x, isCurrent) {  this._send(VALUE, x, isCurrent)  },
	    _handlePrimaryError: function(x, isCurrent) {  this._send(ERROR, x, isCurrent)  },
	    _handlePrimaryEnd: function(__, isCurrent) {  this._send(END, null, isCurrent)  },

	    _handleSecondaryValue: function(x, isCurrent) {  this._lastSecondary = x  },
	    _handleSecondaryError: function(x, isCurrent) {  this._send(ERROR, x, isCurrent)  },
	    _handleSecondaryEnd: function(__, isCurrent) {},

	    _handlePrimaryAny: function(event) {
	      switch (event.type) {
	        case VALUE:
	          this._handlePrimaryValue(event.value, event.current);
	          break;
	        case ERROR:
	          this._handlePrimaryError(event.value, event.current);
	          break;
	        case END:
	          this._handlePrimaryEnd(event.value, event.current);
	          break;
	      }
	    },
	    _handleSecondaryAny: function(event) {
	      switch (event.type) {
	        case VALUE:
	          this._handleSecondaryValue(event.value, event.current);
	          break;
	        case ERROR:
	          this._handleSecondaryError(event.value, event.current);
	          break;
	        case END:
	          this._handleSecondaryEnd(event.value, event.current);
	          this._removeSecondary();
	          break;
	      }
	    },

	    _removeSecondary: function() {
	      if (this._secondary !== null) {
	        this._secondary.offAny(this._$handleSecondaryAny);
	        this._$handleSecondaryAny = null;
	        this._secondary = null;
	      }
	    },

	    _onActivation: function() {
	      if (this._secondary !== null) {
	        this._secondary.onAny(this._$handleSecondaryAny);
	      }
	      if (this._alive) {
	        this._primary.onAny(this._$handlePrimaryAny);
	      }
	    },
	    _onDeactivation: function() {
	      if (this._secondary !== null) {
	        this._secondary.offAny(this._$handleSecondaryAny);
	      }
	      this._primary.offAny(this._$handlePrimaryAny);
	    }
	  }, mixin || {});



	  function buildClass(BaseClass) {
	    function AnonymousObservable(primary, secondary, args) {
	      BaseClass.call(this);
	      this._primary = primary;
	      this._secondary = secondary;
	      this._name = primary._name + '.' + name;
	      this._lastSecondary = NOTHING;
	      var $ = this;
	      this._$handleSecondaryAny = function(event) {  $._handleSecondaryAny(event)  }
	      this._$handlePrimaryAny = function(event) {  $._handlePrimaryAny(event)  }
	      this._init(args);
	    }

	    inherit(AnonymousObservable, BaseClass, {
	      _clear: function() {
	        BaseClass.prototype._clear.call(this);
	        this._primary = null;
	        this._secondary = null;
	        this._lastSecondary = null;
	        this._$handleSecondaryAny = null;
	        this._$handlePrimaryAny = null;
	        this._free();
	      }
	    }, mixin);

	    return AnonymousObservable;
	  }


	  var AnonymousStream = buildClass(Stream);
	  var AnonymousProperty = buildClass(Property);

	  Stream.prototype[name] = function(secondary) {
	    return new AnonymousStream(this, secondary, rest(arguments, 1, []));
	  }

	  Property.prototype[name] = function(secondary) {
	    return new AnonymousProperty(this, secondary, rest(arguments, 1, []));
	  }

	}

	// Subscribers

	function Subscribers() {
	  this._items = [];
	}

	extend(Subscribers, {
	  callOne: function(fnData, event) {
	    if (fnData.type === ANY) {
	      fnData.fn(event);
	    } else if (fnData.type === event.type) {
	      if (fnData.type === VALUE || fnData.type === ERROR) {
	        fnData.fn(event.value);
	      } else {
	        fnData.fn();
	      }
	    }
	  },
	  callOnce: function(type, fn, event) {
	    if (type === ANY) {
	      fn(event);
	    } else if (type === event.type) {
	      if (type === VALUE || type === ERROR) {
	        fn(event.value);
	      } else {
	        fn();
	      }
	    }
	  }
	});


	extend(Subscribers.prototype, {
	  add: function(type, fn, _key) {
	    this._items = concat(this._items, [{
	      type: type,
	      fn: fn,
	      key: _key || null
	    }]);
	  },
	  remove: function(type, fn, _key) {
	    var pred = isArray(_key) ?
	      function(fnData) {return fnData.type === type && isEqualArrays(fnData.key, _key)} :
	      function(fnData) {return fnData.type === type && fnData.fn === fn};
	    this._items = removeByPred(this._items, pred);
	  },
	  callAll: function(event) {
	    var items = this._items;
	    for (var i = 0; i < items.length; i++) {
	      Subscribers.callOne(items[i], event);
	    }
	  },
	  isEmpty: function() {
	    return this._items.length === 0;
	  }
	});





	// Events

	function Event(type, value, current) {
	  return {type: type, value: value, current: !!current};
	}

	var CURRENT_END = Event(END, undefined, true);





	// Observable

	function Observable() {
	  this._subscribers = new Subscribers();
	  this._active = false;
	  this._alive = true;
	}
	Kefir.Observable = Observable;

	extend(Observable.prototype, {

	  _name: 'observable',

	  _onActivation: function() {},
	  _onDeactivation: function() {},

	  _setActive: function(active) {
	    if (this._active !== active) {
	      this._active = active;
	      if (active) {
	        this._onActivation();
	      } else {
	        this._onDeactivation();
	      }
	    }
	  },

	  _clear: function() {
	    this._setActive(false);
	    this._alive = false;
	    this._subscribers = null;
	  },

	  _send: function(type, x, isCurrent) {
	    if (this._alive) {
	      this._subscribers.callAll(Event(type, x, isCurrent));
	      if (type === END) {  this._clear()  }
	    }
	  },

	  _on: function(type, fn, _key) {
	    if (this._alive) {
	      this._subscribers.add(type, fn, _key);
	      this._setActive(true);
	    } else {
	      Subscribers.callOnce(type, fn, CURRENT_END);
	    }
	    return this;
	  },

	  _off: function(type, fn, _key) {
	    if (this._alive) {
	      this._subscribers.remove(type, fn, _key);
	      if (this._subscribers.isEmpty()) {
	        this._setActive(false);
	      }
	    }
	    return this;
	  },

	  onValue:  function(fn, _key) {  return this._on(VALUE, fn, _key)   },
	  onError:  function(fn, _key) {  return this._on(ERROR, fn, _key)   },
	  onEnd:    function(fn, _key) {  return this._on(END, fn, _key)     },
	  onAny:    function(fn, _key) {  return this._on(ANY, fn, _key)     },

	  offValue: function(fn, _key) {  return this._off(VALUE, fn, _key)  },
	  offError: function(fn, _key) {  return this._off(ERROR, fn, _key)  },
	  offEnd:   function(fn, _key) {  return this._off(END, fn, _key)    },
	  offAny:   function(fn, _key) {  return this._off(ANY, fn, _key)    }

	});


	// extend() can't handle `toString` in IE8
	Observable.prototype.toString = function() {  return '[' + this._name + ']'  };









	// Stream

	function Stream() {
	  Observable.call(this);
	}
	Kefir.Stream = Stream;

	inherit(Stream, Observable, {

	  _name: 'stream'

	});







	// Property

	function Property() {
	  Observable.call(this);
	  this._current = NOTHING;
	  this._currentError = NOTHING;
	}
	Kefir.Property = Property;

	inherit(Property, Observable, {

	  _name: 'property',

	  _send: function(type, x, isCurrent) {
	    if (this._alive) {
	      if (!isCurrent) {
	        this._subscribers.callAll(Event(type, x));
	      }
	      if (type === VALUE) {  this._current = x  }
	      if (type === ERROR) {  this._currentError = x  }
	      if (type === END) {  this._clear()  }
	    }
	  },

	  _on: function(type, fn, _key) {
	    if (this._alive) {
	      this._subscribers.add(type, fn, _key);
	      this._setActive(true);
	    }
	    if (this._current !== NOTHING) {
	      Subscribers.callOnce(type, fn, Event(VALUE, this._current, true));
	    }
	    if (this._currentError !== NOTHING) {
	      Subscribers.callOnce(type, fn, Event(ERROR, this._currentError, true));
	    }
	    if (!this._alive) {
	      Subscribers.callOnce(type, fn, CURRENT_END);
	    }
	    return this;
	  }

	});






	// Log

	Observable.prototype.log = function(name) {
	  name = name || this.toString();
	  this.onAny(function(event) {
	    var typeStr = '<' + event.type + (event.current ? ':current' : '') + '>';
	    if (event.type === VALUE || event.type === ERROR) {
	      console.log(name, typeStr, event.value);
	    } else {
	      console.log(name, typeStr);
	    }
	  }, ['__logKey__', this, name]);
	  return this;
	}

	Observable.prototype.offLog = function(name) {
	  name = name || this.toString();
	  this.offAny(null, ['__logKey__', this, name]);
	  return this;
	}



	// Kefir.withInterval()

	withInterval('withInterval', {
	  _init: function(args) {
	    this._fn = args[0];
	    var $ = this;
	    this._emitter = {
	      emit: function(x) {  $._send(VALUE, x)  },
	      error: function(x) {  $._send(ERROR, x)  },
	      end: function() {  $._send(END)  }
	    }
	  },
	  _free: function() {
	    this._fn = null;
	    this._emitter = null;
	  },
	  _onTick: function() {
	    this._fn(this._emitter);
	  }
	});





	// Kefir.fromPoll()

	withInterval('fromPoll', {
	  _init: function(args) {
	    this._fn = args[0];
	  },
	  _free: function() {
	    this._fn = null;
	  },
	  _onTick: function() {
	    this._send(VALUE, this._fn());
	  }
	});





	// Kefir.interval()

	withInterval('interval', {
	  _init: function(args) {
	    this._x = args[0];
	  },
	  _free: function() {
	    this._x = null;
	  },
	  _onTick: function() {
	    this._send(VALUE, this._x);
	  }
	});




	// Kefir.sequentially()

	withInterval('sequentially', {
	  _init: function(args) {
	    this._xs = cloneArray(args[0]);
	    if (this._xs.length === 0) {
	      this._send(END)
	    }
	  },
	  _free: function() {
	    this._xs = null;
	  },
	  _onTick: function() {
	    switch (this._xs.length) {
	      case 1:
	        this._send(VALUE, this._xs[0]);
	        this._send(END);
	        break;
	      default:
	        this._send(VALUE, this._xs.shift());
	    }
	  }
	});




	// Kefir.repeatedly()

	withInterval('repeatedly', {
	  _init: function(args) {
	    this._xs = cloneArray(args[0]);
	    this._i = -1;
	  },
	  _onTick: function() {
	    if (this._xs.length > 0) {
	      this._i = (this._i + 1) % this._xs.length;
	      this._send(VALUE, this._xs[this._i]);
	    }
	  }
	});





	// Kefir.later()

	withInterval('later', {
	  _init: function(args) {
	    this._x = args[0];
	  },
	  _free: function() {
	    this._x = null;
	  },
	  _onTick: function() {
	    this._send(VALUE, this._x);
	    this._send(END);
	  }
	});

	function _AbstractPool(options) {
	  Stream.call(this);

	  this._queueLim = get(options, 'queueLim', 0);
	  this._concurLim = get(options, 'concurLim', -1);
	  this._drop = get(options, 'drop', 'new');
	  if (this._concurLim === 0) {
	    throw new Error('options.concurLim can\'t be 0');
	  }

	  var $ = this;
	  this._$handleSubAny = function(event) {  $._handleSubAny(event)  };

	  this._queue = [];
	  this._curSources = [];
	  this._activating = false;
	}

	inherit(_AbstractPool, Stream, {

	  _name: 'abstractPool',

	  _add: function(obj, toObs) {
	    toObs = toObs || id;
	    if (this._concurLim === -1 || this._curSources.length < this._concurLim) {
	      this._addToCur(toObs(obj));
	    } else {
	      if (this._queueLim === -1 || this._queue.length < this._queueLim) {
	        this._addToQueue(toObs(obj));
	      } else if (this._drop === 'old') {
	        this._removeOldest();
	        this._add(toObs(obj));
	      }
	    }
	  },
	  _addAll: function(obss) {
	    var $ = this;
	    forEach(obss, function(obs) {  $._add(obs)  });
	  },
	  _remove: function(obs) {
	    if (this._removeCur(obs) === -1) {
	      this._removeQueue(obs);
	    }
	  },

	  _addToQueue: function(obs) {
	    this._queue = concat(this._queue, [obs]);
	  },
	  _addToCur: function(obs) {
	    this._curSources = concat(this._curSources, [obs]);
	    if (this._active) {  this._subscribe(obs)  }
	  },
	  _subscribe: function(obs) {
	    var $ = this;
	    obs.onAny(this._$handleSubAny);
	    obs.onEnd(function() {  $._removeCur(obs)  }, [this, obs]);
	  },
	  _unsubscribe: function(obs) {
	    obs.offAny(this._$handleSubAny);
	    obs.offEnd(null, [this, obs]);
	  },
	  _handleSubAny: function(event) {
	    if (event.type === VALUE || event.type === ERROR) {
	      this._send(event.type, event.value, event.current && this._activating);
	    }
	  },

	  _removeQueue: function(obs) {
	    var index = find(this._queue, obs);
	    this._queue = remove(this._queue, index);
	    return index;
	  },
	  _removeCur: function(obs) {
	    if (this._active) {  this._unsubscribe(obs)  }
	    var index = find(this._curSources, obs);
	    this._curSources = remove(this._curSources, index);
	    if (index !== -1) {
	      if (this._queue.length !== 0) {
	        this._pullQueue();
	      } else if (this._curSources.length === 0) {
	        this._onEmpty();
	      }
	    }
	    return index;
	  },
	  _removeOldest: function() {
	    this._removeCur(this._curSources[0]);
	  },

	  _pullQueue: function() {
	    if (this._queue.length !== 0) {
	      this._queue = cloneArray(this._queue);
	      this._addToCur(this._queue.shift());
	    }
	  },

	  _onActivation: function() {
	    var sources = this._curSources
	      , i;
	    this._activating = true;
	    for (i = 0; i < sources.length; i++) {  this._subscribe(sources[i])  }
	    this._activating = false;
	  },
	  _onDeactivation: function() {
	    var sources = this._curSources
	      , i;
	    for (i = 0; i < sources.length; i++) {  this._unsubscribe(sources[i])  }
	  },

	  _isEmpty: function() {  return this._curSources.length === 0  },
	  _onEmpty: function() {},

	  _clear: function() {
	    Stream.prototype._clear.call(this);
	    this._queue = null;
	    this._curSources = null;
	    this._$handleSubAny = null;
	  }

	});





	// .merge()

	var MergeLike = {
	  _onEmpty: function() {
	    if (this._initialised) {  this._send(END, null, this._activating)  }
	  }
	};

	function Merge(sources) {
	  _AbstractPool.call(this);
	  if (sources.length === 0) {  this._send(END)  } else {  this._addAll(sources)  }
	  this._initialised = true;
	}

	inherit(Merge, _AbstractPool, extend({_name: 'merge'}, MergeLike));

	Kefir.merge = function(obss) {
	  return new Merge(obss);
	}

	Observable.prototype.merge = function(other) {
	  return Kefir.merge([this, other]);
	}




	// .concat()

	function Concat(sources) {
	  _AbstractPool.call(this, {concurLim: 1, queueLim: -1});
	  if (sources.length === 0) {  this._send(END)  } else {  this._addAll(sources)  }
	  this._initialised = true;
	}

	inherit(Concat, _AbstractPool, extend({_name: 'concat'}, MergeLike));

	Kefir.concat = function(obss) {
	  return new Concat(obss);
	}

	Observable.prototype.concat = function(other) {
	  return Kefir.concat([this, other]);
	}






	// .pool()

	function Pool() {
	  _AbstractPool.call(this);
	}

	inherit(Pool, _AbstractPool, {

	  _name: 'pool',

	  plug: function(obs) {
	    this._add(obs);
	    return this;
	  },
	  unplug: function(obs) {
	    this._remove(obs);
	    return this;
	  }

	});

	Kefir.pool = function() {
	  return new Pool();
	}





	// .bus()

	function Bus() {
	  _AbstractPool.call(this);
	}

	inherit(Bus, _AbstractPool, {

	  _name: 'bus',

	  plug: function(obs) {
	    this._add(obs);
	    return this;
	  },
	  unplug: function(obs) {
	    this._remove(obs);
	    return this;
	  },

	  emit: function(x) {
	    this._send(VALUE, x);
	    return this;
	  },
	  error: function(x) {
	    this._send(ERROR, x);
	    return this;
	  },
	  end: function() {
	    this._send(END);
	    return this;
	  }

	});

	Kefir.bus = function() {
	  return new Bus();
	}





	// .flatMap()

	function FlatMap(source, fn, options) {
	  _AbstractPool.call(this, options);
	  this._source = source;
	  this._fn = fn || id;
	  this._mainEnded = false;
	  this._lastCurrent = null;

	  var $ = this;
	  this._$handleMainSource = function(event) {  $._handleMainSource(event)  };
	}

	inherit(FlatMap, _AbstractPool, {

	  _onActivation: function() {
	    _AbstractPool.prototype._onActivation.call(this);
	    if (this._active) {
	      this._activating = true;
	      this._source.onAny(this._$handleMainSource);
	      this._activating = false;
	    }
	  },
	  _onDeactivation: function() {
	    _AbstractPool.prototype._onDeactivation.call(this);
	    this._source.offAny(this._$handleMainSource);
	  },

	  _handleMainSource: function(event) {
	    if (event.type === VALUE) {
	      if (!event.current || this._lastCurrent !== event.value) {
	        this._add(event.value, this._fn);
	      }
	      this._lastCurrent = event.value;
	    }
	    if (event.type === ERROR) {
	      this._send(ERROR, event.value, event.current);
	    }
	    if (event.type === END) {
	      if (this._isEmpty()) {
	        this._send(END, null, event.current);
	      } else {
	        this._mainEnded = true;
	      }
	    }
	  },

	  _onEmpty: function() {
	    if (this._mainEnded) {  this._send(END)  }
	  },

	  _clear: function() {
	    _AbstractPool.prototype._clear.call(this);
	    this._source = null;
	    this._lastCurrent = null;
	    this._$handleMainSource = null;
	  }

	});

	Observable.prototype.flatMap = function(fn) {
	  return new FlatMap(this, fn)
	    .setName(this, 'flatMap');
	}

	Observable.prototype.flatMapLatest = function(fn) {
	  return new FlatMap(this, fn, {concurLim: 1, drop: 'old'})
	    .setName(this, 'flatMapLatest');
	}

	Observable.prototype.flatMapFirst = function(fn) {
	  return new FlatMap(this, fn, {concurLim: 1})
	    .setName(this, 'flatMapFirst');
	}

	Observable.prototype.flatMapConcat = function(fn) {
	  return new FlatMap(this, fn, {queueLim: -1, concurLim: 1})
	    .setName(this, 'flatMapConcat');
	}

	Observable.prototype.flatMapConcurLimit = function(fn, limit) {
	  var result;
	  if (limit === 0) {
	    result = Kefir.never();
	  } else {
	    if (limit < 0) {  limit = -1  }
	    result = new FlatMap(this, fn, {queueLim: -1, concurLim: limit});
	  }
	  return result.setName(this, 'flatMapConcurLimit');
	}






	// .zip()

	function Zip(sources, combinator) {
	  Stream.call(this);
	  if (sources.length === 0) {
	    this._send(END);
	  } else {
	    this._buffers = map(sources, function(source) {
	      return isArray(source) ? cloneArray(source) : [];
	    });
	    this._sources = map(sources, function(source) {
	      return isArray(source) ? Kefir.never() : source;
	    });
	    this._combinator = combinator ? spread(combinator, this._sources.length) : id;
	    this._aliveCount = 0;
	  }
	}


	inherit(Zip, Stream, {

	  _name: 'zip',

	  _onActivation: function() {
	    var i, length = this._sources.length;
	    this._drainArrays();
	    this._aliveCount = length;
	    for (i = 0; i < length; i++) {
	      this._sources[i].onAny(this._bindHandleAny(i), [this, i]);
	    }
	  },

	  _onDeactivation: function() {
	    for (var i = 0; i < this._sources.length; i++) {
	      this._sources[i].offAny(null, [this, i]);
	    }
	  },

	  _emit: function(isCurrent) {
	    var values = new Array(this._buffers.length);
	    for (var i = 0; i < this._buffers.length; i++) {
	      values[i] = this._buffers[i].shift();
	    }
	    this._send(VALUE, this._combinator(values), isCurrent);
	  },

	  _isFull: function() {
	    for (var i = 0; i < this._buffers.length; i++) {
	      if (this._buffers[i].length === 0) {
	        return false;
	      }
	    }
	    return true;
	  },

	  _emitIfFull: function(isCurrent) {
	    if (this._isFull()) {
	      this._emit(isCurrent);
	    }
	  },

	  _drainArrays: function() {
	    while (this._isFull()) {
	      this._emit(true);
	    }
	  },

	  _bindHandleAny: function(i) {
	    var $ = this;
	    return function(event) {  $._handleAny(i, event)  };
	  },

	  _handleAny: function(i, event) {
	    if (event.type === VALUE) {
	      this._buffers[i].push(event.value);
	      this._emitIfFull(event.current);
	    }
	    if (event.type === ERROR) {
	      this._send(ERROR, event.value, event.current);
	    }
	    if (event.type === END) {
	      this._aliveCount--;
	      if (this._aliveCount === 0) {
	        this._send(END, null, event.current);
	      }
	    }
	  },

	  _clear: function() {
	    Stream.prototype._clear.call(this);
	    this._sources = null;
	    this._buffers = null;
	    this._combinator = null;
	  }

	});

	Kefir.zip = function(sources, combinator) {
	  return new Zip(sources, combinator);
	}

	Observable.prototype.zip = function(other, combinator) {
	  return new Zip([this, other], combinator);
	}






	// .sampledBy()

	function SampledBy(passive, active, combinator) {
	  Stream.call(this);
	  if (active.length === 0) {
	    this._send(END);
	  } else {
	    this._passiveCount = passive.length;
	    this._sources = concat(passive, active);
	    this._combinator = combinator ? spread(combinator, this._sources.length) : id;
	    this._aliveCount = 0;
	    this._currents = new Array(this._sources.length);
	    fillArray(this._currents, NOTHING);
	    this._activating = false;
	    this._emitAfterActivation = false;
	    this._endAfterActivation = false;
	  }
	}


	inherit(SampledBy, Stream, {

	  _name: 'sampledBy',

	  _onActivation: function() {
	    var length = this._sources.length,
	        i;
	    this._aliveCount = length - this._passiveCount;
	    this._activating = true;
	    for (i = 0; i < length; i++) {
	      this._sources[i].onAny(this._bindHandleAny(i), [this, i]);
	    }
	    this._activating = false;
	    if (this._emitAfterActivation) {
	      this._emitAfterActivation = false;
	      this._emitIfFull(true);
	    }
	    if (this._endAfterActivation) {
	      this._send(END, null, true);
	    }
	  },

	  _onDeactivation: function() {
	    var length = this._sources.length,
	        i;
	    for (i = 0; i < length; i++) {
	      this._sources[i].offAny(null, [this, i]);
	    }
	  },

	  _emitIfFull: function(isCurrent) {
	    if (!contains(this._currents, NOTHING)) {
	      var combined = cloneArray(this._currents);
	      combined = this._combinator(combined);
	      this._send(VALUE, combined, isCurrent);
	    }
	  },

	  _bindHandleAny: function(i) {
	    var $ = this;
	    return function(event) {  $._handleAny(i, event)  };
	  },

	  _handleAny: function(i, event) {
	    if (event.type === VALUE) {
	      this._currents[i] = event.value;
	      if (i >= this._passiveCount) {
	        if (this._activating) {
	          this._emitAfterActivation = true;
	        } else {
	          this._emitIfFull(event.current);
	        }
	      }
	    }
	    if (event.type === ERROR) {
	      this._send(ERROR, event.value, event.current);
	    }
	    if (event.type === END) {
	      if (i >= this._passiveCount) {
	        this._aliveCount--;
	        if (this._aliveCount === 0) {
	          if (this._activating) {
	            this._endAfterActivation = true;
	          } else {
	            this._send(END, null, event.current);
	          }
	        }
	      }
	    }
	  },

	  _clear: function() {
	    Stream.prototype._clear.call(this);
	    this._sources = null;
	    this._currents = null;
	    this._combinator = null;
	  }

	});

	Kefir.sampledBy = function(passive, active, combinator) {
	  return new SampledBy(passive, active, combinator);
	}

	Observable.prototype.sampledBy = function(other, combinator) {
	  return Kefir.sampledBy([this], [other], combinator || id);
	}




	// .combine()

	Kefir.combine = function(sources, combinator) {
	  return new SampledBy([], sources, combinator).setName('combine');
	}

	Observable.prototype.combine = function(other, combinator) {
	  return Kefir.combine([this, other], combinator);
	}

	function produceStream(StreamClass, PropertyClass) {
	  return function() {  return new StreamClass(this, arguments)  }
	}
	function produceProperty(StreamClass, PropertyClass) {
	  return function() {  return new PropertyClass(this, arguments)  }
	}



	// .toProperty()

	withOneSource('toProperty', {
	  _init: function(args) {
	    if (args.length > 0) {
	      this._send(VALUE, args[0]);
	    }
	  }
	}, {propertyMethod: produceProperty, streamMethod: produceProperty});



	// .withDefault (Deprecated)

	Stream.prototype.withDefault = Stream.prototype.toProperty;
	Property.prototype.withDefault = Property.prototype.toProperty;





	// .changes()

	withOneSource('changes', {
	  _handleValue: function(x, isCurrent) {
	    if (!isCurrent) {
	      this._send(VALUE, x);
	    }
	  },
	  _handleError: function(x, isCurrent) {
	    if (!isCurrent) {
	      this._send(ERROR, x);
	    }
	  }
	}, {
	  streamMethod: function() {
	    return function() {
	      return this;
	    }
	  },
	  propertyMethod: produceStream
	});




	// .withHandler()

	withOneSource('withHandler', {
	  _init: function(args) {
	    this._handler = args[0];
	    this._forcedCurrent = false;
	    var $ = this;
	    this._emitter = {
	      emit: function(x) {  $._send(VALUE, x, $._forcedCurrent)  },
	      error: function(x) {  $._send(ERROR, x, $._forcedCurrent)  },
	      end: function() {  $._send(END, null, $._forcedCurrent)  }
	    }
	  },
	  _free: function() {
	    this._handler = null;
	    this._emitter = null;
	  },
	  _handleAny: function(event) {
	    this._forcedCurrent = event.current;
	    this._handler(this._emitter, event);
	    this._forcedCurrent = false;
	  }
	});




	// .flatten(fn)

	withOneSource('flatten', {
	  _init: function(args) {
	    this._fn = args[0] ? args[0] : id;
	  },
	  _free: function() {
	    this._fn = null;
	  },
	  _handleValue: function(x, isCurrent) {
	    var xs = this._fn(x);
	    for (var i = 0; i < xs.length; i++) {
	      this._send(VALUE, xs[i], isCurrent);
	    }
	  }
	});







	// .transduce(transducer)

	function xformForObs(obs) {
	  return {
	    step: function(res, input) {
	      obs._send(VALUE, input, obs._forcedCurrent);
	      return null;
	    },
	    result: function(res) {
	      obs._send(END, null, obs._forcedCurrent);
	      return null;
	    }
	  };
	}

	withOneSource('transduce', {
	  _init: function(args) {
	    this._xform = args[0](xformForObs(this));
	  },
	  _free: function() {
	    this._xform = null;
	  },
	  _handleValue: function(x, isCurrent) {
	    this._forcedCurrent = isCurrent;
	    if (this._xform.step(null, x) !== null) {
	      this._xform.result(null);
	    }
	    this._forcedCurrent = false;
	  },
	  _handleEnd: function(__, isCurrent) {
	    this._forcedCurrent = isCurrent;
	    this._xform.result(null);
	    this._forcedCurrent = false;
	  }
	});





	var withFnArgMixin = {
	  _init: function(args) {  this._fn = args[0] || id  },
	  _free: function() {  this._fn = null  }
	};



	// .map(fn)

	withOneSource('map', extend({
	  _handleValue: function(x, isCurrent) {
	    this._send(VALUE, this._fn(x), isCurrent);
	  }
	}, withFnArgMixin));




	// .mapErrors(fn)

	withOneSource('mapErrors', extend({
	  _handleError: function(x, isCurrent) {
	    this._send(ERROR, this._fn(x), isCurrent);
	  }
	}, withFnArgMixin));



	// .errorsToValues(fn)

	function defaultErrorsToValuesHandler(x) {
	  return {
	    convert: true,
	    value: x
	  };
	}

	withOneSource('errorsToValues', extend({
	  _init: function(args) {
	    this._fn = args[0] || defaultErrorsToValuesHandler;
	  },
	  _free: function() {
	    this._fn = null;
	  },
	  _handleError: function(x, isCurrent) {
	    var result = this._fn(x);
	    var type = result.convert ? VALUE : ERROR;
	    var newX = result.convert ? result.value : x;
	    this._send(type, newX, isCurrent);
	  }
	}));



	// .valuesToErrors(fn)

	function defaultValuesToErrorsHandler(x) {
	  return {
	    convert: true,
	    error: x
	  };
	}

	withOneSource('valuesToErrors', extend({
	  _init: function(args) {
	    this._fn = args[0] || defaultValuesToErrorsHandler;
	  },
	  _free: function() {
	    this._fn = null;
	  },
	  _handleValue: function(x, isCurrent) {
	    var result = this._fn(x);
	    var type = result.convert ? ERROR : VALUE;
	    var newX = result.convert ? result.error : x;
	    this._send(type, newX, isCurrent);
	  }
	}));




	// .filter(fn)

	withOneSource('filter', extend({
	  _handleValue: function(x, isCurrent) {
	    if (this._fn(x)) {
	      this._send(VALUE, x, isCurrent);
	    }
	  }
	}, withFnArgMixin));




	// .filterErrors(fn)

	withOneSource('filterErrors', extend({
	  _handleError: function(x, isCurrent) {
	    if (this._fn(x)) {
	      this._send(ERROR, x, isCurrent);
	    }
	  }
	}, withFnArgMixin));




	// .takeWhile(fn)

	withOneSource('takeWhile', extend({
	  _handleValue: function(x, isCurrent) {
	    if (this._fn(x)) {
	      this._send(VALUE, x, isCurrent);
	    } else {
	      this._send(END, null, isCurrent);
	    }
	  }
	}, withFnArgMixin));





	// .take(n)

	withOneSource('take', {
	  _init: function(args) {
	    this._n = args[0];
	    if (this._n <= 0) {
	      this._send(END);
	    }
	  },
	  _handleValue: function(x, isCurrent) {
	    this._n--;
	    this._send(VALUE, x, isCurrent);
	    if (this._n === 0) {
	      this._send(END, null, isCurrent);
	    }
	  }
	});





	// .skip(n)

	withOneSource('skip', {
	  _init: function(args) {
	    this._n = Math.max(0, args[0]);
	  },
	  _handleValue: function(x, isCurrent) {
	    if (this._n === 0) {
	      this._send(VALUE, x, isCurrent);
	    } else {
	      this._n--;
	    }
	  }
	});




	// .skipDuplicates([fn])

	withOneSource('skipDuplicates', {
	  _init: function(args) {
	    this._fn = args[0] || strictEqual;
	    this._prev = NOTHING;
	  },
	  _free: function() {
	    this._fn = null;
	    this._prev = null;
	  },
	  _handleValue: function(x, isCurrent) {
	    if (this._prev === NOTHING || !this._fn(this._prev, x)) {
	      this._send(VALUE, x, isCurrent);
	      this._prev = x;
	    }
	  }
	});





	// .skipWhile(fn)

	withOneSource('skipWhile', {
	  _init: function(args) {
	    this._fn = args[0] || id;
	    this._skip = true;
	  },
	  _free: function() {
	    this._fn = null;
	  },
	  _handleValue: function(x, isCurrent) {
	    if (!this._skip) {
	      this._send(VALUE, x, isCurrent);
	      return;
	    }
	    if (!this._fn(x)) {
	      this._skip = false;
	      this._fn = null;
	      this._send(VALUE, x, isCurrent);
	    }
	  }
	});





	// .diff(fn, seed)

	withOneSource('diff', {
	  _init: function(args) {
	    this._fn = args[0] || defaultDiff;
	    this._prev = args.length > 1 ? args[1] : NOTHING;
	  },
	  _free: function() {
	    this._prev = null;
	    this._fn = null;
	  },
	  _handleValue: function(x, isCurrent) {
	    if (this._prev !== NOTHING) {
	      this._send(VALUE, this._fn(this._prev, x), isCurrent);
	    }
	    this._prev = x;
	  }
	});





	// .scan(fn, seed)

	withOneSource('scan', {
	  _init: function(args) {
	    this._fn = args[0];
	    if (args.length > 1) {
	      this._send(VALUE, args[1], true);
	    }
	  },
	  _free: function() {
	    this._fn = null;
	  },
	  _handleValue: function(x, isCurrent) {
	    if (this._current !== NOTHING) {
	      x = this._fn(this._current, x);
	    }
	    this._send(VALUE, x, isCurrent);
	  }
	}, {streamMethod: produceProperty});





	// .reduce(fn, seed)

	withOneSource('reduce', {
	  _init: function(args) {
	    this._fn = args[0];
	    this._result = args.length > 1 ? args[1] : NOTHING;
	  },
	  _free: function() {
	    this._fn = null;
	    this._result = null;
	  },
	  _handleValue: function(x) {
	    this._result = (this._result === NOTHING) ? x : this._fn(this._result, x);
	  },
	  _handleEnd: function(__, isCurrent) {
	    if (this._result !== NOTHING) {
	      this._send(VALUE, this._result, isCurrent);
	    }
	    this._send(END, null, isCurrent);
	  }
	});




	// .mapEnd(fn)

	withOneSource('mapEnd', {
	  _init: function(args) {
	    this._fn = args[0];
	  },
	  _free: function() {
	    this._fn = null;
	  },
	  _handleEnd: function(__, isCurrent) {
	    this._send(VALUE, this._fn(), isCurrent);
	    this._send(END, null, isCurrent);
	  }
	});




	// .skipValue()

	withOneSource('skipValues', {
	  _handleValue: function() {}
	});



	// .skipError()

	withOneSource('skipErrors', {
	  _handleError: function() {}
	});



	// .skipEnd()

	withOneSource('skipEnd', {
	  _handleEnd: function() {}
	});



	// .endOnError(fn)

	withOneSource('endOnError', extend({
	  _handleError: function(x, isCurrent) {
	    this._send(ERROR, x, isCurrent);
	    this._send(END, null, isCurrent);
	  }
	}));



	// .slidingWindow(max[, min])

	withOneSource('slidingWindow', {
	  _init: function(args) {
	    this._max = args[0];
	    this._min = args[1] || 0;
	    this._buff = [];
	  },
	  _free: function() {
	    this._buff = null;
	  },
	  _handleValue: function(x, isCurrent) {
	    this._buff = slide(this._buff, x, this._max);
	    if (this._buff.length >= this._min) {
	      this._send(VALUE, this._buff, isCurrent);
	    }
	  }
	});




	// .bufferWhile([predicate], [options])

	withOneSource('bufferWhile', {
	  _init: function(args) {
	    this._fn = args[0] || id;
	    this._flushOnEnd = get(args[1], 'flushOnEnd', true);
	    this._buff = [];
	  },
	  _free: function() {
	    this._buff = null;
	  },
	  _flush: function(isCurrent) {
	    if (this._buff !== null && this._buff.length !== 0) {
	      this._send(VALUE, this._buff, isCurrent);
	      this._buff = [];
	    }
	  },
	  _handleValue: function(x, isCurrent) {
	    this._buff.push(x);
	    if (!this._fn(x)) {
	      this._flush(isCurrent);
	    }
	  },
	  _handleEnd: function(x, isCurrent) {
	    if (this._flushOnEnd) {
	      this._flush(isCurrent);
	    }
	    this._send(END, null, isCurrent);
	  }
	});





	// .debounce(wait, {immediate})

	withOneSource('debounce', {
	  _init: function(args) {
	    this._wait = Math.max(0, args[0]);
	    this._immediate = get(args[1], 'immediate', false);
	    this._lastAttempt = 0;
	    this._timeoutId = null;
	    this._laterValue = null;
	    this._endLater = false;
	    var $ = this;
	    this._$later = function() {  $._later()  };
	  },
	  _free: function() {
	    this._laterValue = null;
	    this._$later = null;
	  },
	  _handleValue: function(x, isCurrent) {
	    if (isCurrent) {
	      this._send(VALUE, x, isCurrent);
	    } else {
	      this._lastAttempt = now();
	      if (this._immediate && !this._timeoutId) {
	        this._send(VALUE, x);
	      }
	      if (!this._timeoutId) {
	        this._timeoutId = setTimeout(this._$later, this._wait);
	      }
	      if (!this._immediate) {
	        this._laterValue = x;
	      }
	    }
	  },
	  _handleEnd: function(__, isCurrent) {
	    if (isCurrent) {
	      this._send(END, null, isCurrent);
	    } else {
	      if (this._timeoutId && !this._immediate) {
	        this._endLater = true;
	      } else {
	        this._send(END);
	      }
	    }
	  },
	  _later: function() {
	    var last = now() - this._lastAttempt;
	    if (last < this._wait && last >= 0) {
	      this._timeoutId = setTimeout(this._$later, this._wait - last);
	    } else {
	      this._timeoutId = null;
	      if (!this._immediate) {
	        this._send(VALUE, this._laterValue);
	        this._laterValue = null;
	      }
	      if (this._endLater) {
	        this._send(END);
	      }
	    }
	  }
	});





	// .throttle(wait, {leading, trailing})

	withOneSource('throttle', {
	  _init: function(args) {
	    this._wait = Math.max(0, args[0]);
	    this._leading = get(args[1], 'leading', true);
	    this._trailing = get(args[1], 'trailing', true);
	    this._trailingValue = null;
	    this._timeoutId = null;
	    this._endLater = false;
	    this._lastCallTime = 0;
	    var $ = this;
	    this._$trailingCall = function() {  $._trailingCall()  };
	  },
	  _free: function() {
	    this._trailingValue = null;
	    this._$trailingCall = null;
	  },
	  _handleValue: function(x, isCurrent) {
	    if (isCurrent) {
	      this._send(VALUE, x, isCurrent);
	    } else {
	      var curTime = now();
	      if (this._lastCallTime === 0 && !this._leading) {
	        this._lastCallTime = curTime;
	      }
	      var remaining = this._wait - (curTime - this._lastCallTime);
	      if (remaining <= 0) {
	        this._cancelTraling();
	        this._lastCallTime = curTime;
	        this._send(VALUE, x);
	      } else if (this._trailing) {
	        this._cancelTraling();
	        this._trailingValue = x;
	        this._timeoutId = setTimeout(this._$trailingCall, remaining);
	      }
	    }
	  },
	  _handleEnd: function(__, isCurrent) {
	    if (isCurrent) {
	      this._send(END, null, isCurrent);
	    } else {
	      if (this._timeoutId) {
	        this._endLater = true;
	      } else {
	        this._send(END);
	      }
	    }
	  },
	  _cancelTraling: function() {
	    if (this._timeoutId !== null) {
	      clearTimeout(this._timeoutId);
	      this._timeoutId = null;
	    }
	  },
	  _trailingCall: function() {
	    this._send(VALUE, this._trailingValue);
	    this._timeoutId = null;
	    this._trailingValue = null;
	    this._lastCallTime = !this._leading ? 0 : now();
	    if (this._endLater) {
	      this._send(END);
	    }
	  }
	});





	// .delay()

	withOneSource('delay', {
	  _init: function(args) {
	    this._wait = Math.max(0, args[0]);
	    this._buff = [];
	    var $ = this;
	    this._$shiftBuff = function() {  $._send(VALUE, $._buff.shift())  }
	  },
	  _free: function() {
	    this._buff = null;
	    this._$shiftBuff = null;
	  },
	  _handleValue: function(x, isCurrent) {
	    if (isCurrent) {
	      this._send(VALUE, x, isCurrent);
	    } else {
	      this._buff.push(x);
	      setTimeout(this._$shiftBuff, this._wait);
	    }
	  },
	  _handleEnd: function(__, isCurrent) {
	    if (isCurrent) {
	      this._send(END, null, isCurrent);
	    } else {
	      var $ = this;
	      setTimeout(function() {  $._send(END)  }, this._wait);
	    }
	  }
	});

	// Kefir.fromBinder(fn)

	function FromBinder(fn) {
	  Stream.call(this);
	  this._fn = fn;
	  this._unsubscribe = null;
	}

	inherit(FromBinder, Stream, {

	  _name: 'fromBinder',

	  _onActivation: function() {
	    var $ = this
	      , isCurrent = true
	      , emitter = {
	        emit: function(x) {  $._send(VALUE, x, isCurrent)  },
	        error: function(x) {  $._send(ERROR, x, isCurrent)  },
	        end: function() {  $._send(END, null, isCurrent)  }
	      };
	    this._unsubscribe = this._fn(emitter) || null;
	    isCurrent = false;
	  },
	  _onDeactivation: function() {
	    if (this._unsubscribe !== null) {
	      this._unsubscribe();
	      this._unsubscribe = null;
	    }
	  },

	  _clear: function() {
	    Stream.prototype._clear.call(this);
	    this._fn = null;
	  }

	})

	Kefir.fromBinder = function(fn) {
	  return new FromBinder(fn);
	}






	// Kefir.emitter()

	function Emitter() {
	  Stream.call(this);
	}

	inherit(Emitter, Stream, {
	  _name: 'emitter',
	  emit: function(x) {
	    this._send(VALUE, x);
	    return this;
	  },
	  error: function(x) {
	    this._send(ERROR, x);
	    return this;
	  },
	  end: function() {
	    this._send(END);
	    return this;
	  }
	});

	Kefir.emitter = function() {
	  return new Emitter();
	}

	Kefir.Emitter = Emitter;







	// Kefir.never()

	var neverObj = new Stream();
	neverObj._send(END);
	neverObj._name = 'never';
	Kefir.never = function() {  return neverObj  }





	// Kefir.constant(x)

	function Constant(x) {
	  Property.call(this);
	  this._send(VALUE, x);
	  this._send(END);
	}

	inherit(Constant, Property, {
	  _name: 'constant'
	})

	Kefir.constant = function(x) {
	  return new Constant(x);
	}




	// Kefir.constantError(x)

	function ConstantError(x) {
	  Property.call(this);
	  this._send(ERROR, x);
	  this._send(END);
	}

	inherit(ConstantError, Property, {
	  _name: 'constantError'
	})

	Kefir.constantError = function(x) {
	  return new ConstantError(x);
	}


	// .setName

	Observable.prototype.setName = function(sourceObs, selfName /* or just selfName */) {
	  this._name = selfName ? sourceObs._name + '.' + selfName : sourceObs;
	  return this;
	}



	// .mapTo

	Observable.prototype.mapTo = function(value) {
	  return this.map(function() {  return value  }).setName(this, 'mapTo');
	}



	// .pluck

	Observable.prototype.pluck = function(propertyName) {
	  return this.map(function(x) {
	    return x[propertyName];
	  }).setName(this, 'pluck');
	}



	// .invoke

	Observable.prototype.invoke = function(methodName /*, arg1, arg2... */) {
	  var args = rest(arguments, 1);
	  return this.map(args ?
	    function(x) {  return apply(x[methodName], x, args)  } :
	    function(x) {  return x[methodName]()  }
	  ).setName(this, 'invoke');
	}




	// .timestamp

	Observable.prototype.timestamp = function() {
	  return this.map(function(x) {  return {value: x, time: now()}  }).setName(this, 'timestamp');
	}




	// .tap

	Observable.prototype.tap = function(fn) {
	  return this.map(function(x) {
	    fn(x);
	    return x;
	  }).setName(this, 'tap');
	}



	// .and

	Kefir.and = function(observables) {
	  return Kefir.combine(observables, and).setName('and');
	}

	Observable.prototype.and = function(other) {
	  return this.combine(other, and).setName('and');
	}



	// .or

	Kefir.or = function(observables) {
	  return Kefir.combine(observables, or).setName('or');
	}

	Observable.prototype.or = function(other) {
	  return this.combine(other, or).setName('or');
	}



	// .not

	Observable.prototype.not = function() {
	  return this.map(not).setName(this, 'not');
	}



	// .awaiting

	Observable.prototype.awaiting = function(other) {
	  return Kefir.merge([
	    this.mapTo(true),
	    other.mapTo(false)
	  ]).skipDuplicates().toProperty(false).setName(this, 'awaiting');
	}




	// .fromCallback

	Kefir.fromCallback = function(callbackConsumer) {
	  var called = false;
	  return Kefir.fromBinder(function(emitter) {
	    if (!called) {
	      callbackConsumer(function(x) {
	        emitter.emit(x);
	        emitter.end();
	      });
	      called = true;
	    }
	  }).setName('fromCallback');
	}




	// .fromNodeCallback

	Kefir.fromNodeCallback = function(callbackConsumer) {
	  var called = false;
	  return Kefir.fromBinder(function(emitter) {
	    if (!called) {
	      callbackConsumer(function(error, x) {
	        if (error) {
	          emitter.error(error);
	        } else {
	          emitter.emit(x);
	        }
	        emitter.end();
	      });
	      called = true;
	    }
	  }).setName('fromNodeCallback');
	}




	// .fromPromise

	Kefir.fromPromise = function(promise) {
	  var called = false;
	  return Kefir.fromBinder(function(emitter) {
	    if (!called) {
	      var onValue = function(x) {
	        emitter.emit(x);
	        emitter.end();
	      };
	      var onError = function(x) {
	        emitter.error(x);
	        emitter.end();
	      };
	      var _promise = promise.then(onValue, onError);

	      // prevent promise/A+ libraries like Q to swallow exceptions
	      if (_promise && isFn(_promise.done)) {
	        _promise.done();
	      }

	      called = true;
	    }
	  }).toProperty().setName('fromPromise');
	}






	// .fromSubUnsub

	Kefir.fromSubUnsub = function(sub, unsub, transformer) {
	  return Kefir.fromBinder(function(emitter) {
	    var handler = transformer ? function() {
	      emitter.emit(apply(transformer, this, arguments));
	    } : emitter.emit;
	    sub(handler);
	    return function() {  unsub(handler)  };
	  });
	}




	// .fromEvent

	var subUnsubPairs = [
	  ['addEventListener', 'removeEventListener'],
	  ['addListener', 'removeListener'],
	  ['on', 'off']
	];

	Kefir.fromEvent = function(target, eventName, transformer) {
	  var pair, sub, unsub;

	  for (var i = 0; i < subUnsubPairs.length; i++) {
	    pair = subUnsubPairs[i];
	    if (isFn(target[pair[0]]) && isFn(target[pair[1]])) {
	      sub = pair[0];
	      unsub = pair[1];
	      break;
	    }
	  }

	  if (sub === undefined) {
	    throw new Error('target don\'t support any of ' +
	      'addEventListener/removeEventListener, addListener/removeListener, on/off method pair');
	  }

	  return Kefir.fromSubUnsub(
	    function(handler) {  target[sub](eventName, handler)  },
	    function(handler) {  target[unsub](eventName, handler)  },
	    transformer
	  ).setName('fromEvent');
	}

	var withTwoSourcesAndBufferMixin = {
	  _init: function(args) {
	    this._buff = [];
	    this._flushOnEnd = get(args[0], 'flushOnEnd', true);
	  },
	  _free: function() {
	    this._buff = null;
	  },
	  _flush: function(isCurrent) {
	    if (this._buff !== null && this._buff.length !== 0) {
	      this._send(VALUE, this._buff, isCurrent);
	      this._buff = [];
	    }
	  },

	  _handlePrimaryEnd: function(__, isCurrent) {
	    if (this._flushOnEnd) {
	      this._flush(isCurrent);
	    }
	    this._send(END, null, isCurrent);
	  }
	};



	withTwoSources('bufferBy', extend({

	  _onActivation: function() {
	    this._primary.onAny(this._$handlePrimaryAny);
	    if (this._alive && this._secondary !== null) {
	      this._secondary.onAny(this._$handleSecondaryAny);
	    }
	  },

	  _handlePrimaryValue: function(x, isCurrent) {
	    this._buff.push(x);
	  },

	  _handleSecondaryValue: function(x, isCurrent) {
	    this._flush(isCurrent);
	  },

	  _handleSecondaryEnd: function(x, isCurrent) {
	    if (!this._flushOnEnd) {
	      this._send(END, null, isCurrent);
	    }
	  }

	}, withTwoSourcesAndBufferMixin));




	withTwoSources('bufferWhileBy', extend({

	  _handlePrimaryValue: function(x, isCurrent) {
	    this._buff.push(x);
	    if (this._lastSecondary !== NOTHING && !this._lastSecondary) {
	      this._flush(isCurrent);
	    }
	  },

	  _handleSecondaryEnd: function(x, isCurrent) {
	    if (!this._flushOnEnd && (this._lastSecondary === NOTHING || this._lastSecondary)) {
	      this._send(END, null, isCurrent);
	    }
	  }

	}, withTwoSourcesAndBufferMixin));





	withTwoSources('filterBy', {

	  _handlePrimaryValue: function(x, isCurrent) {
	    if (this._lastSecondary !== NOTHING && this._lastSecondary) {
	      this._send(VALUE, x, isCurrent);
	    }
	  },

	  _handleSecondaryEnd: function(__, isCurrent) {
	    if (this._lastSecondary === NOTHING || !this._lastSecondary) {
	      this._send(END, null, isCurrent);
	    }
	  }

	});



	withTwoSources('skipUntilBy', {

	  _handlePrimaryValue: function(x, isCurrent) {
	    if (this._lastSecondary !== NOTHING) {
	      this._send(VALUE, x, isCurrent);
	    }
	  },

	  _handleSecondaryEnd: function(__, isCurrent) {
	    if (this._lastSecondary === NOTHING) {
	      this._send(END, null, isCurrent);
	    }
	  }

	});



	withTwoSources('takeUntilBy', {

	  _handleSecondaryValue: function(x, isCurrent) {
	    this._send(END, null, isCurrent);
	  }

	});



	withTwoSources('takeWhileBy', {

	  _handlePrimaryValue: function(x, isCurrent) {
	    if (this._lastSecondary !== NOTHING) {
	      this._send(VALUE, x, isCurrent);
	    }
	  },

	  _handleSecondaryValue: function(x, isCurrent) {
	    this._lastSecondary = x;
	    if (!this._lastSecondary) {
	      this._send(END, null, isCurrent);
	    }
	  },

	  _handleSecondaryEnd: function(__, isCurrent) {
	    if (this._lastSecondary === NOTHING) {
	      this._send(END, null, isCurrent);
	    }
	  }

	});




	withTwoSources('skipWhileBy', {

	  _init: function() {
	    this._hasFalseyFromSecondary = false;
	  },

	  _handlePrimaryValue: function(x, isCurrent) {
	    if (this._hasFalseyFromSecondary) {
	      this._send(VALUE, x, isCurrent);
	    }
	  },

	  _handleSecondaryValue: function(x, isCurrent) {
	    this._hasFalseyFromSecondary = this._hasFalseyFromSecondary || !x;
	  },

	  _handleSecondaryEnd: function(__, isCurrent) {
	    if (!this._hasFalseyFromSecondary) {
	      this._send(END, null, isCurrent);
	    }
	  }

	});


	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return Kefir;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    global.Kefir = Kefir;
	  } else if (typeof module === "object" && typeof exports === "object") {
	    module.exports = Kefir;
	    Kefir.Kefir = Kefir;
	  } else {
	    global.Kefir = Kefir;
	  }

	}(this));

/***/ }
/******/ ]);
    return {
        kefir: kefir
    };
})();
var PS = PS || {};
PS.Data_Html_Internal_VirtualDOM = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    
var virtualDOM =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	var diff    = __webpack_require__(15);
	var patch   = __webpack_require__(16);
	var create  = __webpack_require__(14);
	var VNode   = __webpack_require__(22);
	var VText   = __webpack_require__(23);
	var isHook  = __webpack_require__(3);

	var softSetHook = __webpack_require__(21);

	module.exports =
	  { diff:        diff
	  , patch:       patch
	  , create:      create
	  , vnode:       VNode
	  , vtext:       VText
	  , isHook:      isHook
	  , softSetHook: softSetHook
	  }


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = isWidget

	function isWidget(w) {
	    return w && w.type === "Widget"
	}


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = "1"


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = isHook

	function isHook(hook) {
	    return hook && typeof hook.hook === "function" &&
	        !hook.hasOwnProperty("hook")
	}


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var version = __webpack_require__(2)

	module.exports = isVirtualNode

	function isVirtualNode(x) {
	    return x && x.type === "VirtualNode" && x.version === version
	}


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = isThunk

	function isThunk(t) {
	    return t && t.type === "Thunk"
	}


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var version = __webpack_require__(2)

	module.exports = isVirtualText

	function isVirtualText(x) {
	    return x && x.type === "VirtualText" && x.version === version
	}


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {var topLevel = typeof global !== 'undefined' ? global :
	    typeof window !== 'undefined' ? window : {}
	var minDoc = __webpack_require__(25);

	if (typeof document !== 'undefined') {
	    module.exports = document;
	} else {
	    var doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];

	    if (!doccy) {
	        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
	    }

	    module.exports = doccy;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = function isObject(x) {
		return typeof x === "object" && x !== null;
	};


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var nativeIsArray = Array.isArray
	var toString = Object.prototype.toString

	module.exports = nativeIsArray || isArray

	function isArray(obj) {
	    return toString.call(obj) === "[object Array]"
	}


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(8)
	var isHook = __webpack_require__(3)

	module.exports = applyProperties

	function applyProperties(node, props, previous) {
	    for (var propName in props) {
	        var propValue = props[propName]

	        if (propValue === undefined) {
	            removeProperty(node, props, previous, propName);
	        } else if (isHook(propValue)) {
	            propValue.hook(node,
	                propName,
	                previous ? previous[propName] : undefined)
	        } else {
	            if (isObject(propValue)) {
	                patchObject(node, props, previous, propName, propValue);
	            } else if (propValue !== undefined) {
	                node[propName] = propValue
	            }
	        }
	    }
	}

	function removeProperty(node, props, previous, propName) {
	    if (previous) {
	        var previousValue = previous[propName]

	        if (!isHook(previousValue)) {
	            if (propName === "attributes") {
	                for (var attrName in previousValue) {
	                    node.removeAttribute(attrName)
	                }
	            } else if (propName === "style") {
	                for (var i in previousValue) {
	                    node.style[i] = ""
	                }
	            } else if (typeof previousValue === "string") {
	                node[propName] = ""
	            } else {
	                node[propName] = null
	            }
	        } else if (previousValue.unhook) {
	            previousValue.unhook(node, propName)
	        }
	    }
	}

	function patchObject(node, props, previous, propName, propValue) {
	    var previousValue = previous ? previous[propName] : undefined

	    // Set attributes
	    if (propName === "attributes") {
	        for (var attrName in propValue) {
	            var attrValue = propValue[attrName]

	            if (attrValue === undefined) {
	                node.removeAttribute(attrName)
	            } else {
	                node.setAttribute(attrName, attrValue)
	            }
	        }

	        return
	    }

	    if(previousValue && isObject(previousValue) &&
	        getPrototype(previousValue) !== getPrototype(propValue)) {
	        node[propName] = propValue
	        return
	    }

	    if (!isObject(node[propName])) {
	        node[propName] = {}
	    }

	    var replacer = propName === "style" ? "" : undefined

	    for (var k in propValue) {
	        var value = propValue[k]
	        node[propName][k] = (value === undefined) ? replacer : value
	    }
	}

	function getPrototype(value) {
	    if (Object.getPrototypeOf) {
	        return Object.getPrototypeOf(value)
	    } else if (value.__proto__) {
	        return value.__proto__
	    } else if (value.constructor) {
	        return value.constructor.prototype
	    }
	}


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var document = __webpack_require__(7)

	var applyProperties = __webpack_require__(10)

	var isVNode = __webpack_require__(4)
	var isVText = __webpack_require__(6)
	var isWidget = __webpack_require__(1)
	var handleThunk = __webpack_require__(12)

	module.exports = createElement

	function createElement(vnode, opts) {
	    var doc = opts ? opts.document || document : document
	    var warn = opts ? opts.warn : null

	    vnode = handleThunk(vnode).a

	    if (isWidget(vnode)) {
	        return vnode.init()
	    } else if (isVText(vnode)) {
	        return doc.createTextNode(vnode.text)
	    } else if (!isVNode(vnode)) {
	        if (warn) {
	            warn("Item is not a valid virtual dom node", vnode)
	        }
	        return null
	    }

	    var node = (vnode.namespace === null) ?
	        doc.createElement(vnode.tagName) :
	        doc.createElementNS(vnode.namespace, vnode.tagName)

	    var props = vnode.properties
	    applyProperties(node, props)

	    var children = vnode.children

	    for (var i = 0; i < children.length; i++) {
	        var childNode = createElement(children[i], opts)
	        if (childNode) {
	            node.appendChild(childNode)
	        }
	    }

	    return node
	}


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var isVNode = __webpack_require__(4)
	var isVText = __webpack_require__(6)
	var isWidget = __webpack_require__(1)
	var isThunk = __webpack_require__(5)

	module.exports = handleThunk

	function handleThunk(a, b) {
	    var renderedA = a
	    var renderedB = b

	    if (isThunk(b)) {
	        renderedB = renderThunk(b, a)
	    }

	    if (isThunk(a)) {
	        renderedA = renderThunk(a, null)
	    }

	    return {
	        a: renderedA,
	        b: renderedB
	    }
	}

	function renderThunk(thunk, previous) {
	    var renderedThunk = thunk.vnode

	    if (!renderedThunk) {
	        renderedThunk = thunk.vnode = thunk.render(previous)
	    }

	    if (!(isVNode(renderedThunk) ||
	            isVText(renderedThunk) ||
	            isWidget(renderedThunk))) {
	        throw new Error("thunk did not return a valid node");
	    }

	    return renderedThunk
	}


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var version = __webpack_require__(2)

	VirtualPatch.NONE = 0
	VirtualPatch.VTEXT = 1
	VirtualPatch.VNODE = 2
	VirtualPatch.WIDGET = 3
	VirtualPatch.PROPS = 4
	VirtualPatch.ORDER = 5
	VirtualPatch.INSERT = 6
	VirtualPatch.REMOVE = 7
	VirtualPatch.THUNK = 8

	module.exports = VirtualPatch

	function VirtualPatch(type, vNode, patch) {
	    this.type = Number(type)
	    this.vNode = vNode
	    this.patch = patch
	}

	VirtualPatch.prototype.version = version
	VirtualPatch.prototype.type = "VirtualPatch"


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var createElement = __webpack_require__(11)

	module.exports = createElement


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var diff = __webpack_require__(24)

	module.exports = diff


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var patch = __webpack_require__(19)

	module.exports = patch


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	// Maps a virtual DOM tree onto a real DOM tree in an efficient manner.
	// We don't want to read all of the DOM nodes in the tree so we use
	// the in-order tree indexing to eliminate recursion down certain branches.
	// We only recurse into a DOM node if we know that it contains a child of
	// interest.

	var noChild = {}

	module.exports = domIndex

	function domIndex(rootNode, tree, indices, nodes) {
	    if (!indices || indices.length === 0) {
	        return {}
	    } else {
	        indices.sort(ascending)
	        return recurse(rootNode, tree, indices, nodes, 0)
	    }
	}

	function recurse(rootNode, tree, indices, nodes, rootIndex) {
	    nodes = nodes || {}


	    if (rootNode) {
	        if (indexInRange(indices, rootIndex, rootIndex)) {
	            nodes[rootIndex] = rootNode
	        }

	        var vChildren = tree.children

	        if (vChildren) {

	            var childNodes = rootNode.childNodes

	            for (var i = 0; i < tree.children.length; i++) {
	                rootIndex += 1

	                var vChild = vChildren[i] || noChild
	                var nextIndex = rootIndex + (vChild.count || 0)

	                // skip recursion down the tree if there are no nodes down here
	                if (indexInRange(indices, rootIndex, nextIndex)) {
	                    recurse(childNodes[i], vChild, indices, nodes, rootIndex)
	                }

	                rootIndex = nextIndex
	            }
	        }
	    }

	    return nodes
	}

	// Binary search for an index in the interval [left, right]
	function indexInRange(indices, left, right) {
	    if (indices.length === 0) {
	        return false
	    }

	    var minIndex = 0
	    var maxIndex = indices.length - 1
	    var currentIndex
	    var currentItem

	    while (minIndex <= maxIndex) {
	        currentIndex = ((maxIndex + minIndex) / 2) >> 0
	        currentItem = indices[currentIndex]

	        if (minIndex === maxIndex) {
	            return currentItem >= left && currentItem <= right
	        } else if (currentItem < left) {
	            minIndex = currentIndex + 1
	        } else  if (currentItem > right) {
	            maxIndex = currentIndex - 1
	        } else {
	            return true
	        }
	    }

	    return false;
	}

	function ascending(a, b) {
	    return a > b ? 1 : -1
	}


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var applyProperties = __webpack_require__(10)

	var isWidget = __webpack_require__(1)
	var VPatch = __webpack_require__(13)

	var render = __webpack_require__(11)
	var updateWidget = __webpack_require__(20)

	module.exports = applyPatch

	function applyPatch(vpatch, domNode, renderOptions) {
	    var type = vpatch.type
	    var vNode = vpatch.vNode
	    var patch = vpatch.patch

	    switch (type) {
	        case VPatch.REMOVE:
	            return removeNode(domNode, vNode)
	        case VPatch.INSERT:
	            return insertNode(domNode, patch, renderOptions)
	        case VPatch.VTEXT:
	            return stringPatch(domNode, vNode, patch, renderOptions)
	        case VPatch.WIDGET:
	            return widgetPatch(domNode, vNode, patch, renderOptions)
	        case VPatch.VNODE:
	            return vNodePatch(domNode, vNode, patch, renderOptions)
	        case VPatch.ORDER:
	            reorderChildren(domNode, patch)
	            return domNode
	        case VPatch.PROPS:
	            applyProperties(domNode, patch, vNode.properties)
	            return domNode
	        case VPatch.THUNK:
	            return replaceRoot(domNode,
	                renderOptions.patch(domNode, patch, renderOptions))
	        default:
	            return domNode
	    }
	}

	function removeNode(domNode, vNode) {
	    var parentNode = domNode.parentNode

	    if (parentNode) {
	        parentNode.removeChild(domNode)
	    }

	    destroyWidget(domNode, vNode);

	    return null
	}

	function insertNode(parentNode, vNode, renderOptions) {
	    var newNode = render(vNode, renderOptions)

	    if (parentNode) {
	        parentNode.appendChild(newNode)
	    }

	    return parentNode
	}

	function stringPatch(domNode, leftVNode, vText, renderOptions) {
	    var newNode

	    if (domNode.nodeType === 3) {
	        domNode.replaceData(0, domNode.length, vText.text)
	        newNode = domNode
	    } else {
	        var parentNode = domNode.parentNode
	        newNode = render(vText, renderOptions)

	        if (parentNode) {
	            parentNode.replaceChild(newNode, domNode)
	        }
	    }

	    return newNode
	}

	function widgetPatch(domNode, leftVNode, widget, renderOptions) {
	    var updating = updateWidget(leftVNode, widget)
	    var newNode

	    if (updating) {
	        newNode = widget.update(leftVNode, domNode) || domNode
	    } else {
	        newNode = render(widget, renderOptions)
	    }

	    var parentNode = domNode.parentNode

	    if (parentNode && newNode !== domNode) {
	        parentNode.replaceChild(newNode, domNode)
	    }

	    if (!updating) {
	        destroyWidget(domNode, leftVNode)
	    }

	    return newNode
	}

	function vNodePatch(domNode, leftVNode, vNode, renderOptions) {
	    var parentNode = domNode.parentNode
	    var newNode = render(vNode, renderOptions)

	    if (parentNode) {
	        parentNode.replaceChild(newNode, domNode)
	    }

	    return newNode
	}

	function destroyWidget(domNode, w) {
	    if (typeof w.destroy === "function" && isWidget(w)) {
	        w.destroy(domNode)
	    }
	}

	function reorderChildren(domNode, bIndex) {
	    var children = []
	    var childNodes = domNode.childNodes
	    var len = childNodes.length
	    var i
	    var reverseIndex = bIndex.reverse

	    for (i = 0; i < len; i++) {
	        children.push(domNode.childNodes[i])
	    }

	    var insertOffset = 0
	    var move
	    var node
	    var insertNode
	    var chainLength
	    var insertedLength
	    var nextSibling
	    for (i = 0; i < len;) {
	        move = bIndex[i]
	        chainLength = 1
	        if (move !== undefined && move !== i) {
	            // try to bring forward as long of a chain as possible
	            while (bIndex[i + chainLength] === move + chainLength) {
	                chainLength++;
	            }

	            // the element currently at this index will be moved later so increase the insert offset
	            if (reverseIndex[i] > i + chainLength) {
	                insertOffset++
	            }

	            node = children[move]
	            insertNode = childNodes[i + insertOffset] || null
	            insertedLength = 0
	            while (node !== insertNode && insertedLength++ < chainLength) {
	                domNode.insertBefore(node, insertNode);
	                node = children[move + insertedLength];
	            }

	            // the moved element came from the front of the array so reduce the insert offset
	            if (move + chainLength < i) {
	                insertOffset--
	            }
	        }

	        // element at this index is scheduled to be removed so increase insert offset
	        if (i in bIndex.removes) {
	            insertOffset++
	        }

	        i += chainLength
	    }
	}

	function replaceRoot(oldRoot, newRoot) {
	    if (oldRoot && newRoot && oldRoot !== newRoot && oldRoot.parentNode) {
	        console.log(oldRoot)
	        oldRoot.parentNode.replaceChild(newRoot, oldRoot)
	    }

	    return newRoot;
	}


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var document = __webpack_require__(7)
	var isArray = __webpack_require__(9)

	var domIndex = __webpack_require__(17)
	var patchOp = __webpack_require__(18)
	module.exports = patch

	function patch(rootNode, patches) {
	    return patchRecursive(rootNode, patches)
	}

	function patchRecursive(rootNode, patches, renderOptions) {
	    var indices = patchIndices(patches)

	    if (indices.length === 0) {
	        return rootNode
	    }

	    var index = domIndex(rootNode, patches.a, indices)
	    var ownerDocument = rootNode.ownerDocument

	    if (!renderOptions) {
	        renderOptions = { patch: patchRecursive }
	        if (ownerDocument !== document) {
	            renderOptions.document = ownerDocument
	        }
	    }

	    for (var i = 0; i < indices.length; i++) {
	        var nodeIndex = indices[i]
	        rootNode = applyPatch(rootNode,
	            index[nodeIndex],
	            patches[nodeIndex],
	            renderOptions)
	    }

	    return rootNode
	}

	function applyPatch(rootNode, domNode, patchList, renderOptions) {
	    if (!domNode) {
	        return rootNode
	    }

	    var newNode

	    if (isArray(patchList)) {
	        for (var i = 0; i < patchList.length; i++) {
	            newNode = patchOp(patchList[i], domNode, renderOptions)

	            if (domNode === rootNode) {
	                rootNode = newNode
	            }
	        }
	    } else {
	        newNode = patchOp(patchList, domNode, renderOptions)

	        if (domNode === rootNode) {
	            rootNode = newNode
	        }
	    }

	    return rootNode
	}

	function patchIndices(patches) {
	    var indices = []

	    for (var key in patches) {
	        if (key !== "a") {
	            indices.push(Number(key))
	        }
	    }

	    return indices
	}


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var isWidget = __webpack_require__(1)

	module.exports = updateWidget

	function updateWidget(a, b) {
	    if (isWidget(a) && isWidget(b)) {
	        if ("name" in a && "name" in b) {
	            return a.id === b.id
	        } else {
	            return a.init === b.init
	        }
	    }

	    return false
	}


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = SoftSetHook;

	function SoftSetHook(value) {
	    if (!(this instanceof SoftSetHook)) {
	        return new SoftSetHook(value);
	    }

	    this.value = value;
	}

	SoftSetHook.prototype.hook = function (node, propertyName) {
	    if (node[propertyName] !== this.value) {
	        node[propertyName] = this.value;
	    }
	};


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var version = __webpack_require__(2)
	var isVNode = __webpack_require__(4)
	var isWidget = __webpack_require__(1)
	var isThunk = __webpack_require__(5)
	var isVHook = __webpack_require__(3)

	module.exports = VirtualNode

	var noProperties = {}
	var noChildren = []

	function VirtualNode(tagName, properties, children, key, namespace) {
	    this.tagName = tagName
	    this.properties = properties || noProperties
	    this.children = children || noChildren
	    this.key = key != null ? String(key) : undefined
	    this.namespace = (typeof namespace === "string") ? namespace : null

	    var count = (children && children.length) || 0
	    var descendants = 0
	    var hasWidgets = false
	    var hasThunks = false
	    var descendantHooks = false
	    var hooks

	    for (var propName in properties) {
	        if (properties.hasOwnProperty(propName)) {
	            var property = properties[propName]
	            if (isVHook(property) && property.unhook) {
	                if (!hooks) {
	                    hooks = {}
	                }

	                hooks[propName] = property
	            }
	        }
	    }

	    for (var i = 0; i < count; i++) {
	        var child = children[i]
	        if (isVNode(child)) {
	            descendants += child.count || 0

	            if (!hasWidgets && child.hasWidgets) {
	                hasWidgets = true
	            }

	            if (!hasThunks && child.hasThunks) {
	                hasThunks = true
	            }

	            if (!descendantHooks && (child.hooks || child.descendantHooks)) {
	                descendantHooks = true
	            }
	        } else if (!hasWidgets && isWidget(child)) {
	            if (typeof child.destroy === "function") {
	                hasWidgets = true
	            }
	        } else if (!hasThunks && isThunk(child)) {
	            hasThunks = true;
	        }
	    }

	    this.count = count + descendants
	    this.hasWidgets = hasWidgets
	    this.hasThunks = hasThunks
	    this.hooks = hooks
	    this.descendantHooks = descendantHooks
	}

	VirtualNode.prototype.version = version
	VirtualNode.prototype.type = "VirtualNode"


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var version = __webpack_require__(2)

	module.exports = VirtualText

	function VirtualText(text) {
	    this.text = String(text)
	}

	VirtualText.prototype.version = version
	VirtualText.prototype.type = "VirtualText"


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(9)
	var isObject = __webpack_require__(8)

	var VPatch = __webpack_require__(13)
	var isVNode = __webpack_require__(4)
	var isVText = __webpack_require__(6)
	var isWidget = __webpack_require__(1)
	var isThunk = __webpack_require__(5)
	var isHook = __webpack_require__(3)
	var handleThunk = __webpack_require__(12)

	module.exports = diff

	function diff(a, b) {
	    var patch = { a: a }
	    walk(a, b, patch, 0)
	    return patch
	}

	function walk(a, b, patch, index) {
	    if (a === b) {
	        return
	    }

	    var apply = patch[index]
	    var applyClear = false

	    if (isThunk(a) || isThunk(b)) {
	        thunks(a, b, patch, index)
	    } else if (b == null) {

	        // If a is a widget we will add a remove patch for it
	        // Otherwise any child widgets/hooks must be destroyed.
	        // This prevents adding two remove patches for a widget.
	        if (!isWidget(a)) {
	            clearState(a, patch, index)
	            apply = patch[index]
	        }

	        apply = appendPatch(apply, new VPatch(VPatch.REMOVE, a, b))
	    } else if (isVNode(b)) {
	        if (isVNode(a)) {
	            if (a.tagName === b.tagName &&
	                a.namespace === b.namespace &&
	                a.key === b.key) {
	                var propsPatch = diffProps(a.properties, b.properties)
	                if (propsPatch) {
	                    apply = appendPatch(apply,
	                        new VPatch(VPatch.PROPS, a, propsPatch))
	                }
	                apply = diffChildren(a, b, patch, apply, index)
	            } else {
	                apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b))
	                applyClear = true
	            }
	        } else {
	            apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b))
	            applyClear = true
	        }
	    } else if (isVText(b)) {
	        if (!isVText(a)) {
	            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b))
	            applyClear = true
	        } else if (a.text !== b.text) {
	            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b))
	        }
	    } else if (isWidget(b)) {
	        if (!isWidget(a)) {
	            applyClear = true;
	        }

	        apply = appendPatch(apply, new VPatch(VPatch.WIDGET, a, b))
	    }

	    if (apply) {
	        patch[index] = apply
	    }

	    if (applyClear) {
	        clearState(a, patch, index)
	    }
	}

	function diffProps(a, b) {
	    var diff

	    for (var aKey in a) {
	        if (!(aKey in b)) {
	            diff = diff || {}
	            diff[aKey] = undefined
	        }

	        var aValue = a[aKey]
	        var bValue = b[aKey]

	        if (aValue === bValue) {
	            continue
	        } else if (isObject(aValue) && isObject(bValue)) {
	            if (getPrototype(bValue) !== getPrototype(aValue)) {
	                diff = diff || {}
	                diff[aKey] = bValue
	            } else if (isHook(bValue)) {
	                 diff = diff || {}
	                 diff[aKey] = bValue
	            } else {
	                var objectDiff = diffProps(aValue, bValue)
	                if (objectDiff) {
	                    diff = diff || {}
	                    diff[aKey] = objectDiff
	                }
	            }
	        } else {
	            diff = diff || {}
	            diff[aKey] = bValue
	        }
	    }

	    for (var bKey in b) {
	        if (!(bKey in a)) {
	            diff = diff || {}
	            diff[bKey] = b[bKey]
	        }
	    }

	    return diff
	}

	function getPrototype(value) {
	    if (Object.getPrototypeOf) {
	        return Object.getPrototypeOf(value)
	    } else if (value.__proto__) {
	        return value.__proto__
	    } else if (value.constructor) {
	        return value.constructor.prototype
	    }
	}

	function diffChildren(a, b, patch, apply, index) {
	    var aChildren = a.children
	    var bChildren = reorder(aChildren, b.children)

	    var aLen = aChildren.length
	    var bLen = bChildren.length
	    var len = aLen > bLen ? aLen : bLen

	    for (var i = 0; i < len; i++) {
	        var leftNode = aChildren[i]
	        var rightNode = bChildren[i]
	        index += 1

	        if (!leftNode) {
	            if (rightNode) {
	                // Excess nodes in b need to be added
	                apply = appendPatch(apply,
	                    new VPatch(VPatch.INSERT, null, rightNode))
	            }
	        } else {
	            walk(leftNode, rightNode, patch, index)
	        }

	        if (isVNode(leftNode) && leftNode.count) {
	            index += leftNode.count
	        }
	    }

	    if (bChildren.moves) {
	        // Reorder nodes last
	        apply = appendPatch(apply, new VPatch(VPatch.ORDER, a, bChildren.moves))
	    }

	    return apply
	}

	function clearState(vNode, patch, index) {
	    // TODO: Make this a single walk, not two
	    unhook(vNode, patch, index)
	    destroyWidgets(vNode, patch, index)
	}

	// Patch records for all destroyed widgets must be added because we need
	// a DOM node reference for the destroy function
	function destroyWidgets(vNode, patch, index) {
	    if (isWidget(vNode)) {
	        if (typeof vNode.destroy === "function") {
	            patch[index] = appendPatch(
	                patch[index],
	                new VPatch(VPatch.REMOVE, vNode, null)
	            )
	        }
	    } else if (isVNode(vNode) && (vNode.hasWidgets || vNode.hasThunks)) {
	        var children = vNode.children
	        var len = children.length
	        for (var i = 0; i < len; i++) {
	            var child = children[i]
	            index += 1

	            destroyWidgets(child, patch, index)

	            if (isVNode(child) && child.count) {
	                index += child.count
	            }
	        }
	    } else if (isThunk(vNode)) {
	        thunks(vNode, null, patch, index)
	    }
	}

	// Create a sub-patch for thunks
	function thunks(a, b, patch, index) {
	    var nodes = handleThunk(a, b);
	    var thunkPatch = diff(nodes.a, nodes.b)
	    if (hasPatches(thunkPatch)) {
	        patch[index] = new VPatch(VPatch.THUNK, null, thunkPatch)
	    }
	}

	function hasPatches(patch) {
	    for (var index in patch) {
	        if (index !== "a") {
	            return true;
	        }
	    }

	    return false;
	}

	// Execute hooks when two nodes are identical
	function unhook(vNode, patch, index) {
	    if (isVNode(vNode)) {
	        if (vNode.hooks) {
	            patch[index] = appendPatch(
	                patch[index],
	                new VPatch(
	                    VPatch.PROPS,
	                    vNode,
	                    undefinedKeys(vNode.hooks)
	                )
	            )
	        }

	        if (vNode.descendantHooks || vNode.hasThunks) {
	            var children = vNode.children
	            var len = children.length
	            for (var i = 0; i < len; i++) {
	                var child = children[i]
	                index += 1

	                unhook(child, patch, index)

	                if (isVNode(child) && child.count) {
	                    index += child.count
	                }
	            }
	        }
	    } else if (isThunk(vNode)) {
	        thunks(vNode, null, patch, index)
	    }
	}

	function undefinedKeys(obj) {
	    var result = {}

	    for (var key in obj) {
	        result[key] = undefined
	    }

	    return result
	}

	// List diff, naive left to right reordering
	function reorder(aChildren, bChildren) {

	    var bKeys = keyIndex(bChildren)

	    if (!bKeys) {
	        return bChildren
	    }

	    var aKeys = keyIndex(aChildren)

	    if (!aKeys) {
	        return bChildren
	    }

	    var bMatch = {}, aMatch = {}

	    for (var aKey in bKeys) {
	        bMatch[bKeys[aKey]] = aKeys[aKey]
	    }

	    for (var bKey in aKeys) {
	        aMatch[aKeys[bKey]] = bKeys[bKey]
	    }

	    var aLen = aChildren.length
	    var bLen = bChildren.length
	    var len = aLen > bLen ? aLen : bLen
	    var shuffle = []
	    var freeIndex = 0
	    var i = 0
	    var moveIndex = 0
	    var moves = {}
	    var removes = moves.removes = {}
	    var reverse = moves.reverse = {}
	    var hasMoves = false

	    while (freeIndex < len) {
	        var move = aMatch[i]
	        if (move !== undefined) {
	            shuffle[i] = bChildren[move]
	            if (move !== moveIndex) {
	                moves[move] = moveIndex
	                reverse[moveIndex] = move
	                hasMoves = true
	            }
	            moveIndex++
	        } else if (i in aMatch) {
	            shuffle[i] = undefined
	            removes[i] = moveIndex++
	            hasMoves = true
	        } else {
	            while (bMatch[freeIndex] !== undefined) {
	                freeIndex++
	            }

	            if (freeIndex < len) {
	                var freeChild = bChildren[freeIndex]
	                if (freeChild) {
	                    shuffle[i] = freeChild
	                    if (freeIndex !== moveIndex) {
	                        hasMoves = true
	                        moves[freeIndex] = moveIndex
	                        reverse[moveIndex] = freeIndex
	                    }
	                    moveIndex++
	                }
	                freeIndex++
	            }
	        }
	        i++
	    }

	    if (hasMoves) {
	        shuffle.moves = moves
	    }

	    return shuffle
	}

	function keyIndex(children) {
	    var i, keys

	    for (i = 0; i < children.length; i++) {
	        var child = children[i]

	        if (child.key !== undefined) {
	            keys = keys || {}
	            keys[child.key] = i
	        }
	    }

	    return keys
	}

	function appendPatch(apply, patch) {
	    if (apply) {
	        if (isArray(apply)) {
	            apply.push(patch)
	        } else {
	            apply = [apply, patch]
	        }

	        return apply
	    } else {
	        return patch
	    }
	}


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/* (ignored) */

/***/ }
/******/ ]);
    return {
        virtualDOM: virtualDOM
    };
})();
var PS = PS || {};
PS.Data_Function = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    function mkFn2(fn) {  return function(a, b) {    return fn(a)(b);  };};
    function runFn2(fn) {  return function(a) {    return function(b) {      return fn(a, b);    };  };};
    function runFn3(fn) {  return function(a) {    return function(b) {      return function(c) {        return fn(a, b, c);      };    };  };};
    function runFn4(fn) {  return function(a) {    return function(b) {      return function(c) {        return function(d) {          return fn(a, b, c, d);        };      };    };  };};
    return {
        mkFn2: mkFn2, 
        runFn2: runFn2, 
        runFn3: runFn3, 
        runFn4: runFn4
    };
})();
var PS = PS || {};
PS.Data_Html_Internal_Attributes = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    function Attribute(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Attribute.create = function (value0) {
        return function (value1) {
            return new Attribute(value0, value1);
        };
    };
    function Key(value0) {
        this.value0 = value0;
    };
    Key.create = function (value0) {
        return new Key(value0);
    };
    function Namespace(value0) {
        this.value0 = value0;
    };
    Namespace.create = function (value0) {
        return new Namespace(value0);
    };
    var AttrType = {
        create: function (value) {
            return value;
        }
    };
    
function unsafeCoerce(a) {
  return a;
};
    var namespace = 1;
    var key = 2;
    var getNamespaceString = function (_56) {
        if (_56 instanceof Namespace) {
            return _56.value0;
        };
        throw new Error("Failed pattern match");
    };
    var getKeyString = function (_55) {
        if (_55 instanceof Key) {
            return _55.value0;
        };
        throw new Error("Failed pattern match");
    };
    var getAttrValue = function (_54) {
        if (_54 instanceof Attribute) {
            return _54.value1;
        };
        throw new Error("Failed pattern match");
    };
    var getAttrKey = function (_53) {
        if (_53 instanceof Attribute) {
            return _53.value0;
        };
        throw new Error("Failed pattern match");
    };
    var attriute = 0;
    var attribute = Attribute.create;
    var attrTypes = {
        attribute: attriute, 
        namespace: namespace, 
        key: key
    };
    var attrType = function (_52) {
        if (_52 instanceof Attribute) {
            return attriute;
        };
        if (_52 instanceof Namespace) {
            return namespace;
        };
        if (_52 instanceof Key) {
            return key;
        };
        throw new Error("Failed pattern match");
    };
    return {
        Attribute: Attribute, 
        Key: Key, 
        Namespace: Namespace, 
        attrType: attrType, 
        attrTypes: attrTypes, 
        attribute: attribute, 
        attriute: attriute, 
        getAttrKey: getAttrKey, 
        getAttrValue: getAttrValue, 
        getKeyString: getKeyString, 
        getNamespaceString: getNamespaceString, 
        key: key, 
        namespace: namespace, 
        unsafeCoerce: unsafeCoerce
    };
})();
var PS = PS || {};
PS.Control_Monad_Eff = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    function returnE(a) {  return function() {    return a;  };};
    function bindE(a) {  return function(f) {    return function() {      return f(a())();    };  };};
    var monadEff = new Prelude.Monad(function () {
        return applicativeEff;
    }, function () {
        return bindEff;
    });
    var bindEff = new Prelude.Bind(bindE, function () {
        return applyEff;
    });
    var applyEff = new Prelude.Apply(Prelude.ap(monadEff), function () {
        return functorEff;
    });
    var applicativeEff = new Prelude.Applicative(function () {
        return applyEff;
    }, returnE);
    var functorEff = new Prelude.Functor(Prelude.liftA1(applicativeEff));
    return {
        applicativeEff: applicativeEff, 
        applyEff: applyEff, 
        bindE: bindE, 
        bindEff: bindEff, 
        functorEff: functorEff, 
        monadEff: monadEff, 
        returnE: returnE
    };
})();
var PS = PS || {};
PS.Data_Html_Attributes = (function () {
    "use strict";
    var Data_Html_Internal_Attributes = PS.Data_Html_Internal_Attributes;
    var Prelude = PS.Prelude;
    
function mkEvent (fn) {
  return function mkEvHook_callback(ev){
    fn(ev)();
  }
};
    var style = function (v) {
        return Data_Html_Internal_Attributes.attribute("style")(Data_Html_Internal_Attributes.unsafeCoerce(v));
    };
    var stringAttribute = function (n) {
        return function (v) {
            return Data_Html_Internal_Attributes.attribute(n)(Data_Html_Internal_Attributes.unsafeCoerce(v));
        };
    };
    var on_ = function (ev) {
        return function (fn) {
            return Data_Html_Internal_Attributes.attribute("on" + ev)(mkEvent(fn));
        };
    };
    var booleanAttribute = function (n) {
        return function (v) {
            return Data_Html_Internal_Attributes.attribute(n)(Data_Html_Internal_Attributes.unsafeCoerce(v));
        };
    };
    return {
        booleanAttribute: booleanAttribute, 
        on_: on_, 
        stringAttribute: stringAttribute, 
        style: style
    };
})();
var PS = PS || {};
PS.Data_Html_Attributes_Html5 = (function () {
    "use strict";
    var Data_Html_Attributes = PS.Data_Html_Attributes;
    var Prelude = PS.Prelude;
    var value = Data_Html_Attributes.stringAttribute("value");
    var type_ = Data_Html_Attributes.stringAttribute("type");
    var style = Data_Html_Attributes.style;
    var placeholder = Data_Html_Attributes.stringAttribute("placeholder");
    var name = Data_Html_Attributes.stringAttribute("name");
    var id_ = Data_Html_Attributes.stringAttribute("id");
    var href = Data_Html_Attributes.stringAttribute("href");
    var hidden = Data_Html_Attributes.booleanAttribute("hidden");
    var $$for = Data_Html_Attributes.stringAttribute("htmlFor");
    var class_ = Data_Html_Attributes.stringAttribute("className");
    var checked = Data_Html_Attributes.booleanAttribute("checked");
    var autofocus = Data_Html_Attributes.booleanAttribute("autofocus");
    return {
        autofocus: autofocus, 
        checked: checked, 
        class_: class_, 
        "for": $$for, 
        hidden: hidden, 
        href: href, 
        id_: id_, 
        name: name, 
        placeholder: placeholder, 
        style: style, 
        type_: type_, 
        value: value
    };
})();
var PS = PS || {};
PS.Data_Html_Internal_Events = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var MouseButtonEvent = {
        create: function (value) {
            return value;
        }
    };
    var KeyEvent = {
        create: function (value) {
            return value;
        }
    };
    return {
        KeyEvent: KeyEvent, 
        MouseButtonEvent: MouseButtonEvent
    };
})();
var PS = PS || {};
PS.Data_Html_Elements = (function () {
    "use strict";
    var Data_Function = PS.Data_Function;
    var Data_Html_Internal_Attributes = PS.Data_Html_Internal_Attributes;
    var Data_Html_Internal_VirtualDOM = PS.Data_Html_Internal_VirtualDOM;
    var Prelude = PS.Prelude;
    
function vnodeImpl (fn, name, attrs, children) {
  var props     = {}
    , key       = undefined
    , namespace = undefined;

  for(var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];
    var typ  = fn.attrType(attr);
    if(typ === fn.attrTypes.attribute) {
      props[fn.attrKey(attr)] = fn.attrVal(attr);
    } else if (typ === fn.attrTypes.key) {
      key = fn.getKey(attr);
    } else {
      namespace = fn.getNs(attr);
    }
  }

  if( name.toUpperCase() === "INPUT" &&
      !namespace &&
      props.hasOwnProperty('value') &&
      props.value !== undefined &&
      !fn.isHook(props.value)
    ) {
      props.value = fn.softSetHook(props.value);
    }

  return new fn.vnode(name, props, children, key, namespace);
};
    
function vtextImpl(vtext, text){
  return new vtext(text);
};
    var vnode = function (t) {
        return function (a) {
            return function (c) {
                return vnodeImpl({
                    attrType: Data_Html_Internal_Attributes.attrType, 
                    attrTypes: Data_Html_Internal_Attributes.attrTypes, 
                    attrKey: Data_Html_Internal_Attributes.getAttrKey, 
                    attrVal: Data_Html_Internal_Attributes.getAttrValue, 
                    getKey: Data_Html_Internal_Attributes.getKeyString, 
                    getNs: Data_Html_Internal_Attributes.getNamespaceString, 
                    vnode: Data_Html_Internal_VirtualDOM.virtualDOM.vnode, 
                    isHook: Data_Html_Internal_VirtualDOM.virtualDOM.isHook, 
                    softSetHook: Data_Html_Internal_VirtualDOM.virtualDOM.softSetHook
                }, t, a, c);
            };
        };
    };
    var text = function (s) {
        return vtextImpl(Data_Html_Internal_VirtualDOM.virtualDOM.vtext, s);
    };
    return {
        text: text, 
        vnode: vnode
    };
})();
var PS = PS || {};
PS.Data_Html = (function () {
    "use strict";
    var Data_Function = PS.Data_Function;
    var Data_Html_Internal_VirtualDOM = PS.Data_Html_Internal_VirtualDOM;
    var Prelude = PS.Prelude;
    
function createElementImpl(create, vtree){
  return function createElementImplEff(){
    return { vtree: vtree
           , node: create(vtree)
           }
  }
};
    
function getNode(html){
  return function getNodeEff(){
    return html.node;
  }
};
    
function patchImpl(fn, next, html){
  return function patchImplEff(){
    var patch  = fn.diff(html.vtree, next);
    html.node  = fn.patch(html.node, patch);
    html.vtree = next;
  }
};
    var patch = function (v) {
        return function (h) {
            return patchImpl(Data_Html_Internal_VirtualDOM.virtualDOM, v, h);
        };
    };
    var createElement = function (v) {
        return createElementImpl(Data_Html_Internal_VirtualDOM.virtualDOM.create, v);
    };
    return {
        createElement: createElement, 
        getNode: getNode, 
        patch: patch
    };
})();
var PS = PS || {};
PS.Data_Html_Elements_Html5 = (function () {
    "use strict";
    var Data_Html_Elements = PS.Data_Html_Elements;
    var Prelude = PS.Prelude;
    var ul = Data_Html_Elements.vnode("ul");
    var text = Data_Html_Elements.text;
    var strong = Data_Html_Elements.vnode("strong");
    var span = Data_Html_Elements.vnode("span");
    var section = Data_Html_Elements.vnode("section");
    var p = Data_Html_Elements.vnode("p");
    var li = Data_Html_Elements.vnode("li");
    var label = Data_Html_Elements.vnode("label");
    var input = Data_Html_Elements.vnode("input");
    var header = Data_Html_Elements.vnode("header");
    var h1 = Data_Html_Elements.vnode("h1");
    var footer = Data_Html_Elements.vnode("footer");
    var div = Data_Html_Elements.vnode("div");
    var button = Data_Html_Elements.vnode("button");
    var a = Data_Html_Elements.vnode("a");
    return {
        a: a, 
        button: button, 
        div: div, 
        footer: footer, 
        h1: h1, 
        header: header, 
        input: input, 
        label: label, 
        li: li, 
        p: p, 
        section: section, 
        span: span, 
        strong: strong, 
        text: text, 
        ul: ul
    };
})();
var PS = PS || {};
PS.Control_Monad = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var when = function (__dict_Monad_25) {
        return function (_75) {
            return function (_76) {
                if (_75) {
                    return _76;
                };
                if (!_75) {
                    return Prelude["return"](__dict_Monad_25)(Prelude.unit);
                };
                throw new Error("Failed pattern match");
            };
        };
    };
    return {
        when: when
    };
})();
var PS = PS || {};
PS.Data_Array = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Data_Maybe = PS.Data_Maybe;
    function length (xs) {  return xs.length;};
    function append (l1) {  return function (l2) {    return l1.concat(l2);  };};
    function map (f) {  return function (arr) {    var l = arr.length;    var result = new Array(l);    for (var i = 0; i < l; i++) {      result[i] = f(arr[i]);    }    return result;  };};
    function filter (f) {  return function (arr) {    var n = 0;    var result = [];    for (var i = 0, l = arr.length; i < l; i++) {      if (f(arr[i])) {        result[n++] = arr[i];      }    }    return result;  };};
    var semigroupArray = new Prelude.Semigroup(append);
    var $$null = function (_119) {
        if (_119.length === 0) {
            return true;
        };
        return false;
    };
    var functorArray = new Prelude.Functor(map);
    return {
        append: append, 
        filter: filter, 
        functorArray: functorArray, 
        length: length, 
        map: map, 
        "null": $$null, 
        semigroupArray: semigroupArray
    };
})();
var PS = PS || {};
PS.Data_Monoid = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Data_Array = PS.Data_Array;
    function Monoid(__superclass_Prelude$dotSemigroup_0, mempty) {
        this["__superclass_Prelude.Semigroup_0"] = __superclass_Prelude$dotSemigroup_0;
        this.mempty = mempty;
    };
    var monoidArray = new Monoid(function () {
        return Data_Array.semigroupArray;
    }, [  ]);
    var mempty = function (dict) {
        return dict.mempty;
    };
    return {
        Monoid: Monoid, 
        mempty: mempty, 
        monoidArray: monoidArray
    };
})();
var PS = PS || {};
PS.Data_Foldable = (function () {
    "use strict";
    var Data_Monoid = PS.Data_Monoid;
    var Prelude = PS.Prelude;
    var Control_Apply = PS.Control_Apply;
    var Data_Monoid_First = PS.Data_Monoid_First;
    function Foldable(foldMap, foldl, foldr) {
        this.foldMap = foldMap;
        this.foldl = foldl;
        this.foldr = foldr;
    };
    
  function foldrArray(f) {
    return function(z) {
      return function(xs) {
        var acc = z;
        for (var i = xs.length - 1; i >= 0; --i) {
          acc = f(xs[i])(acc);
        }
        return acc;
      }
    }
  };
    
  function foldlArray(f) {
    return function(z) {
      return function(xs) {
        var acc = z;
        for (var i = 0, len = xs.length; i < len; ++i) {
          acc = f(acc)(xs[i]);
        }
        return acc;
      }
    }
  };
    var foldr = function (dict) {
        return dict.foldr;
    };
    var foldl = function (dict) {
        return dict.foldl;
    };
    var foldableArray = new Foldable(function (__dict_Monoid_268) {
        return function (f) {
            return function (xs) {
                return foldr(foldableArray)(function (x) {
                    return function (acc) {
                        return Prelude["<>"](__dict_Monoid_268["__superclass_Prelude.Semigroup_0"]())(f(x))(acc);
                    };
                })(Data_Monoid.mempty(__dict_Monoid_268))(xs);
            };
        };
    }, function (f) {
        return function (z) {
            return function (xs) {
                return foldlArray(f)(z)(xs);
            };
        };
    }, function (f) {
        return function (z) {
            return function (xs) {
                return foldrArray(f)(z)(xs);
            };
        };
    });
    var foldMap = function (dict) {
        return dict.foldMap;
    };
    var and = function (__dict_Foldable_279) {
        return foldl(__dict_Foldable_279)(Prelude["&&"](Prelude.boolLikeBoolean))(true);
    };
    var all = function (__dict_Foldable_280) {
        return function (p) {
            return Prelude["<<<"](Prelude.semigroupoidArr)(and(foldableArray))(foldMap(__dict_Foldable_280)(Data_Monoid.monoidArray)(function (x) {
                return [ p(x) ];
            }));
        };
    };
    return {
        Foldable: Foldable, 
        all: all, 
        and: and, 
        foldMap: foldMap, 
        foldableArray: foldableArray, 
        foldl: foldl, 
        foldlArray: foldlArray, 
        foldr: foldr, 
        foldrArray: foldrArray
    };
})();
var PS = PS || {};
PS.Data_String = (function () {
    "use strict";
    var Data_Function = PS.Data_Function;
    var Data_Char = PS.Data_Char;
    var Data_String_Unsafe = PS.Data_String_Unsafe;
    var Prelude = PS.Prelude;
    
    function length(s) {
      return s.length;
    }
    ;
    var $$null = function (s) {
        return length(s) === 0;
    };
    return {
        length: length, 
        "null": $$null
    };
})();
var PS = PS || {};
PS.Data_Html_Events = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Data_String = PS.Data_String;
    var Data_Function = PS.Data_Function;
    var Data_Html_Attributes = PS.Data_Html_Attributes;
    var Data_Html_Internal_Events = PS.Data_Html_Internal_Events;
    function EventLike() {

    };
    
function eventPropImpl(ev, prop) {
  return ev[prop];
};
    
function keyCode(evt){
  evt = evt || window.event;
  return evt.which || evt.keyCode;
};
    var onKeyDown = function (f) {
        return Data_Html_Attributes.on_("keydown")(Prelude["<<<"](Prelude.semigroupoidArr)(f)(Data_Html_Internal_Events.KeyEvent.create));
    };
    var onInput = Data_Html_Attributes.on_("input");
    var onDoubleClick = function (f) {
        return Data_Html_Attributes.on_("dblclick")(Prelude["<<<"](Prelude.semigroupoidArr)(f)(Data_Html_Internal_Events.MouseButtonEvent.create));
    };
    var onClick = function (f) {
        return Data_Html_Attributes.on_("click")(Prelude["<<<"](Prelude.semigroupoidArr)(f)(Data_Html_Internal_Events.MouseButtonEvent.create));
    };
    var onBlur = Data_Html_Attributes.on_("blur");
    var eventProp = function (ev) {
        return function (p) {
            return eventPropImpl(ev, p);
        };
    };
    var targetValue = function (__dict_EventLike_285) {
        return function (e) {
            return eventProp(eventProp(e)("target"))("value");
        };
    };
    var eventLikeEvent = new EventLike();
    return {
        EventLike: EventLike, 
        eventLikeEvent: eventLikeEvent, 
        keyCode: keyCode, 
        onBlur: onBlur, 
        onClick: onClick, 
        onDoubleClick: onDoubleClick, 
        onInput: onInput, 
        onKeyDown: onKeyDown, 
        targetValue: targetValue
    };
})();
var PS = PS || {};
PS.FRP_Kefir = (function () {
    "use strict";
    var FRP_Kefir_Foreign = PS.FRP_Kefir_Foreign;
    var Data_Function = PS.Data_Function;
    var Data_Either = PS.Data_Either;
    var Prelude = PS.Prelude;
    var Data_Maybe = PS.Data_Maybe;
    var Data_Maybe_Unsafe = PS.Data_Maybe_Unsafe;
    
  function execute(m){
    return m();
  };
    
function emitterImpl(kefir){
  return function EmitterEff(){
    return kefir.emitter();
  }
};
    
function emitAsyncImpl(stream, value){
  return function EmitAsyncEff(){
    setTimeout(function(){stream.emit(value);}, 0);
  }
};
    
function onValueImpl(str, fn){
  return function onValueImplEff(){
    function onValueCallback(x){
      fn(x)();
    };
    str.onValue(onValueCallback);
    return function offValueEff() {
      str.offValue(onValueCallback);
    }
  }
};
    
function scanImpl(f, a, stream){
  return function ScanEff(){
    return stream['scan'](f, a);
  }
};
    var unsafeGlobalize = execute;
    var scan = function (f) {
        return function (a) {
            return function (s) {
                return scanImpl(Data_Function.mkFn2(f), a, s);
            };
        };
    };
    var onValue = function (s) {
        return function (f) {
            return onValueImpl(s, f);
        };
    };
    var emitter = emitterImpl(FRP_Kefir_Foreign.kefir);
    var emitAsync = function (s) {
        return function (a) {
            return emitAsyncImpl(s, a);
        };
    };
    return {
        emitAsync: emitAsync, 
        emitter: emitter, 
        onValue: onValue, 
        scan: scan, 
        unsafeGlobalize: unsafeGlobalize
    };
})();
var PS = PS || {};
PS.Main = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Data_String = PS.Data_String;
    var Data_Array = PS.Data_Array;
    var Data_Html_Elements_Html5 = PS.Data_Html_Elements_Html5;
    var Data_Html_Attributes_Html5 = PS.Data_Html_Attributes_Html5;
    var Data_Html_Events = PS.Data_Html_Events;
    var Control_Monad = PS.Control_Monad;
    var FRP_Kefir = PS.FRP_Kefir;
    var Data_Foldable = PS.Data_Foldable;
    var Data_Html = PS.Data_Html;
    var Control_Monad_Eff = PS.Control_Monad_Eff;
    function All() {

    };
    All.value = new All();
    function Completed() {

    };
    Completed.value = new Completed();
    function Active() {

    };
    Active.value = new Active();
    var TaskId = {
        create: function (value) {
            return value;
        }
    };
    function UpdateField(value0) {
        this.value0 = value0;
    };
    UpdateField.create = function (value0) {
        return new UpdateField(value0);
    };
    function EditingTask(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    EditingTask.create = function (value0) {
        return function (value1) {
            return new EditingTask(value0, value1);
        };
    };
    function UpdateTask(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    UpdateTask.create = function (value0) {
        return function (value1) {
            return new UpdateTask(value0, value1);
        };
    };
    function Add() {

    };
    Add.value = new Add();
    function Delete(value0) {
        this.value0 = value0;
    };
    Delete.create = function (value0) {
        return new Delete(value0);
    };
    function DeleteComplete() {

    };
    DeleteComplete.value = new DeleteComplete();
    function Check(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Check.create = function (value0) {
        return function (value1) {
            return new Check(value0, value1);
        };
    };
    function CheckAll(value0) {
        this.value0 = value0;
    };
    CheckAll.create = function (value0) {
        return new CheckAll(value0);
    };
    function ChangeVisibility(value0) {
        this.value0 = value0;
    };
    ChangeVisibility.create = function (value0) {
        return new ChangeVisibility(value0);
    };
    
function appendBody(node) {
  return function (){
    document.body.appendChild(node);
  }
};
    var updates = FRP_Kefir.unsafeGlobalize(FRP_Kefir.emitter);
    var unTaskId = function (_504) {
        return _504;
    };
    var succTaskId = function (_503) {
        return _503 + 1;
    };
    var showVisibility = new Prelude.Show(function (_509) {
        if (_509 instanceof All) {
            return "All";
        };
        if (_509 instanceof Completed) {
            return "Completed";
        };
        if (_509 instanceof Active) {
            return "Active";
        };
        throw new Error("Failed pattern match");
    });
    var onEnter = function (f) {
        return Data_Html_Events.onKeyDown(function (k) {
            return Control_Monad.when(Control_Monad_Eff.monadEff)(Data_Html_Events.keyCode(k) === 13)(f);
        });
    };
    var taskEntry = function (task) {
        return Data_Html_Elements_Html5.header([ Data_Html_Attributes_Html5.id_("header") ])([ Data_Html_Elements_Html5.h1([  ])([ Data_Html_Elements_Html5.text("todos") ]), Data_Html_Elements_Html5.input([ Data_Html_Attributes_Html5.id_("new-todo"), Data_Html_Attributes_Html5.placeholder("What needs to be done?"), Data_Html_Attributes_Html5.autofocus(true), Data_Html_Attributes_Html5.value(task), Data_Html_Attributes_Html5.name("newTodo"), Data_Html_Events.onInput(function (v) {
            return FRP_Kefir.emitAsync(updates)(UpdateField.create(Data_Html_Events.targetValue(Data_Html_Events.eventLikeEvent)(v)));
        }), onEnter(FRP_Kefir.emitAsync(updates)(Add.value)) ])([  ]) ]);
    };
    var todoItem = function (todo) {
        var className = (todo.completed ? "completed " : "") + (todo.editing ? "editing" : "");
        return Data_Html_Elements_Html5.li([ Data_Html_Attributes_Html5.class_(className) ])([ Data_Html_Elements_Html5.div([ Data_Html_Attributes_Html5.class_("view") ])([ Data_Html_Elements_Html5.input([ Data_Html_Attributes_Html5.class_("toggle"), Data_Html_Attributes_Html5.type_("checkbox"), Data_Html_Attributes_Html5.checked(todo.completed), Data_Html_Events.onClick(function (_) {
            return FRP_Kefir.emitAsync(updates)(new Check(todo.id, !todo.completed));
        }) ])([  ]), Data_Html_Elements_Html5.label([ Data_Html_Events.onDoubleClick(function (_) {
            return FRP_Kefir.emitAsync(updates)(new EditingTask(todo.id, true));
        }) ])([ Data_Html_Elements_Html5.text(todo.description) ]), Data_Html_Elements_Html5.button([ Data_Html_Attributes_Html5.class_("destroy"), Data_Html_Events.onClick(function (_) {
            return FRP_Kefir.emitAsync(updates)(new Delete(todo.id));
        }) ])([  ]) ]), Data_Html_Elements_Html5.input([ Data_Html_Attributes_Html5.class_("edit"), Data_Html_Attributes_Html5.value(todo.description), Data_Html_Attributes_Html5.name("title"), Data_Html_Attributes_Html5.id_("todo-" + Prelude.show(Prelude.showNumber)(unTaskId(todo.id))), Data_Html_Events.onInput(function (v) {
            return FRP_Kefir.emitAsync(updates)(UpdateTask.create(todo.id)(Data_Html_Events.targetValue(Data_Html_Events.eventLikeEvent)(v)));
        }), Data_Html_Events.onBlur(function (_) {
            return FRP_Kefir.emitAsync(updates)(new EditingTask(todo.id, false));
        }), onEnter(FRP_Kefir.emitAsync(updates)(new EditingTask(todo.id, false))) ])([  ]) ]);
    };
    var taskList = function (visibility) {
        return function (tasks) {
            var isVisible = function (todo) {
                if (visibility instanceof Completed) {
                    return todo.completed;
                };
                if (visibility instanceof Active) {
                    return !todo.completed;
                };
                if (visibility instanceof All) {
                    return true;
                };
                throw new Error("Failed pattern match");
            };
            var cssVisibility = Data_Array["null"](tasks) ? "hidden" : "visible";
            var allCompleted = Data_Foldable.all(Data_Foldable.foldableArray)(function (t) {
                return t.completed;
            })(tasks);
            return Data_Html_Elements_Html5.section([ Data_Html_Attributes_Html5.id_("main"), Data_Html_Attributes_Html5.style({
                visibility: cssVisibility
            }) ])([ Data_Html_Elements_Html5.input([ Data_Html_Attributes_Html5.id_("toggle-all"), Data_Html_Attributes_Html5.type_("checkbox"), Data_Html_Attributes_Html5.name("toggle"), Data_Html_Attributes_Html5.checked(allCompleted), Data_Html_Events.onClick(function (_) {
                return FRP_Kefir.emitAsync(updates)(new CheckAll(!allCompleted));
            }) ])([  ]), Data_Html_Elements_Html5.label([ Data_Html_Attributes_Html5["for"]("toggle-all") ])([ Data_Html_Elements_Html5.text("Mark all as complete") ]), Data_Html_Elements_Html5.ul([ Data_Html_Attributes_Html5.id_("todo-list") ])(Prelude["<$>"](Data_Array.functorArray)(todoItem)(Data_Array.filter(isVisible)(tasks))) ]);
        };
    };
    var newTask = function (desc) {
        return function (id) {
            return {
                description: desc, 
                completed: false, 
                editing: false, 
                id: id
            };
        };
    };
    var infoFooter = Data_Html_Elements_Html5.footer([ Data_Html_Attributes_Html5.id_("info") ])([ Data_Html_Elements_Html5.p([  ])([ Data_Html_Elements_Html5.text("Double-click to edit a todo") ]), Data_Html_Elements_Html5.p([  ])([ Data_Html_Elements_Html5.text("Original on "), Data_Html_Elements_Html5.a([ Data_Html_Attributes_Html5.href("https://github.com/evancz/elm-todomvc") ])([ Data_Html_Elements_Html5.text("elm-todomvc") ]) ]) ]);
    var eqVisibility = new Prelude.Eq(function (a) {
        return function (b) {
            return !Prelude["=="](eqVisibility)(a)(b);
        };
    }, function (_507) {
        return function (_508) {
            if (_507 instanceof All && _508 instanceof All) {
                return true;
            };
            if (_507 instanceof Completed && _508 instanceof Completed) {
                return true;
            };
            if (_507 instanceof Active && _508 instanceof Active) {
                return true;
            };
            return false;
        };
    });
    var visibilitySwap = function (uri) {
        return function (visibility) {
            return function (actualVisibility) {
                var className = Prelude["=="](eqVisibility)(visibility)(actualVisibility) ? "selected" : "";
                return Data_Html_Elements_Html5.li([ Data_Html_Events.onClick(function (_) {
                    return FRP_Kefir.emitAsync(updates)(new ChangeVisibility(visibility));
                }) ])([ Data_Html_Elements_Html5.a([ Data_Html_Attributes_Html5.class_(className), Data_Html_Attributes_Html5.href(uri) ])([ Data_Html_Elements_Html5.text(Prelude.show(showVisibility)(visibility)) ]) ]);
            };
        };
    };
    var eqTaskId = new Prelude.Eq(function (a) {
        return function (b) {
            return !Prelude["=="](eqTaskId)(a)(b);
        };
    }, function (_505) {
        return function (_506) {
            return _505 === _506;
        };
    });
    var step = function (state_1) {
        return function (update) {
            if (update instanceof Add) {
                var _539 = {};
                for (var _540 in state_1) {
                    if (state_1.hasOwnProperty(_540)) {
                        _539[_540] = state_1[_540];
                    };
                };
                _539.uid = succTaskId(state_1.uid);
                _539.field = "";
                _539.tasks = Data_String["null"](state_1.field) ? state_1.tasks : Prelude["++"](Data_Array.semigroupArray)(state_1.tasks)([ newTask(state_1.field)(state_1.uid) ]);
                return _539;
            };
            if (update instanceof UpdateField) {
                var _541 = {};
                for (var _542 in state_1) {
                    if (state_1.hasOwnProperty(_542)) {
                        _541[_542] = state_1[_542];
                    };
                };
                _541.field = update.value0;
                return _541;
            };
            if (update instanceof EditingTask) {
                var stepTask = function (t) {
                    return Prelude["=="](eqTaskId)(t.id)(update.value0) ? (function () {
    var _544 = {};
    for (var _545 in t) {
        if (t.hasOwnProperty(_545)) {
            _544[_545] = t[_545];
        };
    };
    _544.editing = update.value1;
    return _544;
})() : t;
                };
                var _546 = {};
                for (var _547 in state_1) {
                    if (state_1.hasOwnProperty(_547)) {
                        _546[_547] = state_1[_547];
                    };
                };
                _546.tasks = Prelude["<$>"](Data_Array.functorArray)(stepTask)(state_1.tasks);
                return _546;
            };
            if (update instanceof UpdateTask) {
                var stepTask = function (t) {
                    return Prelude["=="](eqTaskId)(t.id)(update.value0) ? (function () {
    var _550 = {};
    for (var _551 in t) {
        if (t.hasOwnProperty(_551)) {
            _550[_551] = t[_551];
        };
    };
    _550.description = update.value1;
    return _550;
})() : t;
                };
                var _552 = {};
                for (var _553 in state_1) {
                    if (state_1.hasOwnProperty(_553)) {
                        _552[_553] = state_1[_553];
                    };
                };
                _552.tasks = Prelude["<$>"](Data_Array.functorArray)(stepTask)(state_1.tasks);
                return _552;
            };
            if (update instanceof Delete) {
                var _556 = {};
                for (var _557 in state_1) {
                    if (state_1.hasOwnProperty(_557)) {
                        _556[_557] = state_1[_557];
                    };
                };
                _556.tasks = Data_Array.filter(function (t) {
                    return Prelude["/="](eqTaskId)(t.id)(update.value0);
                })(state_1.tasks);
                return _556;
            };
            if (update instanceof DeleteComplete) {
                var _559 = {};
                for (var _560 in state_1) {
                    if (state_1.hasOwnProperty(_560)) {
                        _559[_560] = state_1[_560];
                    };
                };
                _559.tasks = Data_Array.filter(function (t) {
                    return !t.completed;
                })(state_1.tasks);
                return _559;
            };
            if (update instanceof Check) {
                var stepTask = function (t) {
                    return Prelude["=="](eqTaskId)(t.id)(update.value0) ? (function () {
    var _561 = {};
    for (var _562 in t) {
        if (t.hasOwnProperty(_562)) {
            _561[_562] = t[_562];
        };
    };
    _561.completed = update.value1;
    return _561;
})() : t;
                };
                var _563 = {};
                for (var _564 in state_1) {
                    if (state_1.hasOwnProperty(_564)) {
                        _563[_564] = state_1[_564];
                    };
                };
                _563.tasks = Prelude["<$>"](Data_Array.functorArray)(stepTask)(state_1.tasks);
                return _563;
            };
            if (update instanceof CheckAll) {
                var stepTask = function (t) {
                    var _567 = {};
                    for (var _568 in t) {
                        if (t.hasOwnProperty(_568)) {
                            _567[_568] = t[_568];
                        };
                    };
                    _567.completed = update.value0;
                    return _567;
                };
                var _569 = {};
                for (var _570 in state_1) {
                    if (state_1.hasOwnProperty(_570)) {
                        _569[_570] = state_1[_570];
                    };
                };
                _569.tasks = Prelude["<$>"](Data_Array.functorArray)(stepTask)(state_1.tasks);
                return _569;
            };
            if (update instanceof ChangeVisibility) {
                var _572 = {};
                for (var _573 in state_1) {
                    if (state_1.hasOwnProperty(_573)) {
                        _572[_573] = state_1[_573];
                    };
                };
                _572.visibility = update.value0;
                return _572;
            };
            throw new Error("Failed pattern match");
        };
    };
    var emptyState = {
        tasks: [  ], 
        visibility: All.value, 
        field: "", 
        uid: 0
    };
    var startingState = emptyState;
    var state = FRP_Kefir.unsafeGlobalize(FRP_Kefir.scan(step)(startingState)(updates));
    var controls = function (visibility) {
        return function (tasks) {
            var tasksCompleted = Data_Array.length(Data_Array.filter(function (t) {
                return t.completed;
            })(tasks));
            var tasksLeft = Data_Array.length(tasks) - tasksCompleted;
            var item_ = tasksLeft === 1 ? " item" : " items";
            return Data_Html_Elements_Html5.footer([ Data_Html_Attributes_Html5.id_("footer"), Data_Html_Attributes_Html5.hidden(Data_Array["null"](tasks)) ])([ Data_Html_Elements_Html5.span([ Data_Html_Attributes_Html5.id_("todo-count") ])([ Data_Html_Elements_Html5.strong([  ])([ Data_Html_Elements_Html5.text(Prelude.show(Prelude.showNumber)(tasksLeft)) ]), Data_Html_Elements_Html5.text(item_ + " left") ]), Data_Html_Elements_Html5.ul([ Data_Html_Attributes_Html5.id_("filters") ])([ visibilitySwap("#/")(All.value)(visibility), Data_Html_Elements_Html5.text(" "), visibilitySwap("#/active")(Active.value)(visibility), Data_Html_Elements_Html5.text(" "), visibilitySwap("#/completed")(Completed.value)(visibility) ]), Data_Html_Elements_Html5.button([ Data_Html_Attributes_Html5.class_("clear-completed"), Data_Html_Attributes_Html5.id_("clear-completed"), Data_Html_Attributes_Html5.hidden(tasksCompleted === 0), Data_Html_Events.onClick(function (_) {
                return FRP_Kefir.emitAsync(updates)(DeleteComplete.value);
            }) ])([ Data_Html_Elements_Html5.text("Clear completed (" + (Prelude.show(Prelude.showNumber)(tasksCompleted) + ")")) ]) ]);
        };
    };
    var view = function (state_1) {
        return Data_Html_Elements_Html5.div([ Data_Html_Attributes_Html5.class_("todomvc-wrapper") ])([ Data_Html_Elements_Html5.section([ Data_Html_Attributes_Html5.id_("todoapp") ])([ taskEntry(state_1.field), taskList(state_1.visibility)(state_1.tasks), controls(state_1.visibility)(state_1.tasks) ]), infoFooter ]);
    };
    var main = function __do() {
        var _30 = Data_Html.createElement(Data_Html_Elements_Html5.text("loading..."))();
        Prelude[">>="](Control_Monad_Eff.bindEff)(Data_Html.getNode(_30))(appendBody)();
        return FRP_Kefir.onValue(state)(function (v) {
            return Data_Html.patch(view(v))(_30);
        })();
    };
    return {
        Active: Active, 
        Add: Add, 
        All: All, 
        ChangeVisibility: ChangeVisibility, 
        Check: Check, 
        CheckAll: CheckAll, 
        Completed: Completed, 
        Delete: Delete, 
        DeleteComplete: DeleteComplete, 
        EditingTask: EditingTask, 
        TaskId: TaskId, 
        UpdateField: UpdateField, 
        UpdateTask: UpdateTask, 
        appendBody: appendBody, 
        controls: controls, 
        emptyState: emptyState, 
        eqTaskId: eqTaskId, 
        eqVisibility: eqVisibility, 
        infoFooter: infoFooter, 
        main: main, 
        newTask: newTask, 
        onEnter: onEnter, 
        showVisibility: showVisibility, 
        startingState: startingState, 
        state: state, 
        step: step, 
        succTaskId: succTaskId, 
        taskEntry: taskEntry, 
        taskList: taskList, 
        todoItem: todoItem, 
        unTaskId: unTaskId, 
        updates: updates, 
        view: view, 
        visibilitySwap: visibilitySwap
    };
})();
PS.Main.main();

